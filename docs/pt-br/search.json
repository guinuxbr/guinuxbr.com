[{"categories":["tutoriais"],"content":"Olá, seja bem-vindo ao meu blog!\nO objetivo deste artigo é compartilhar minha configuração de shell com você. Penso que o meu trabalho e as tarefas do dia a dia se tornaram mais fáceis e produtivas comparando com o bash “normal”. Espero que seja útil para você.\nVocê precisará das seguintes ferramentas:\nZsh - O shell Z. Oh-My-Zsh - Um framework para gerenciar sua configuração do Zsh. Starship - Um prompt rápido e personalizável para qualquer shell que funciona muito bem com o Zsh!\nParto do princípio que você já tem o git instalado e sabe utilizá-lo para clonar repositórios.\nInstalando o Zsh Primeiro, você precisa instalar o Zsh. Você pode usar o gerenciador de pacotes da sua distribuição para instalá-lo facilmente.\nPara o openSUSE:\n sudo zypper install zsh\n Para o Ubuntu:\n sudo apt install zsh\n Para o Fedora:\n sudo dnf install zsh\n Depois disso, você deve definir o Zsh como seu shell padrão:\n chsh -s $(which zsh)\n Agora reinicie sua máquina.\nInstalação do Oh-My-Zsh Após a reinicialização, abra o seu terminal e você deverá se deparar com um assistente de configuração do Zsh. Neste momento, você pode digitar q e ENTER porque você vai instalar e configurar o Oh-My-Zsh e ele já traz um modelo do arquivo .zshrc pronto:\n O programa curl ou o wget devem estar instalados. O git deve estar instalado.   sh -c “$ (wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)”\n Se o Oh-My-Zsh foi instalado com sucesso, você verá que seu prompt muda para verde. O arquivo de configuração do modelo é ~/.zshrc que oferece inúmeras possibilidades para configurar o comportamento do seu shell, como temas para o prompt e plugins.\nCarregando alguns plugins Existem muitas configurações que podem ser feitas no Zsh + Oh-My-Zsh, aqui vou falar sobre uma lista de plugins legais que eu uso, mas você pode se aprofundar para descobrir mais possibilidades. Os plugins devem ser colocados na sessão plugins = (...) do arquivo de configuração. Segue uma lista pessoal:\n   nome do plugin breve descrição     colored-man-pages adiciona cores às páginas de manual   command-not-found usa o pacote command-not-found para o Zsh apresentar pacotes sugeridos   docker adiciona “tab-completion” para Docker   git fornece aliases e algumas funções úteis   npm fornece “tab-completion” e muitos aliases úteis   pep8 adiciona “tab-completion” para o comando pep8   pip adiciona “tab-completion” para o comando pip   pyenv carrega pyenv e pyenv-virtualenv   python adiciona vários aliases para comandos python úteis   sudo prefixa o comando atual com sudo pressionando esc duas vezes   systemd fornece aliases úteis para systemd   ubuntu adiciona “tab-completion” e aliases para o Ubuntu   zsh-reload basta digitar src para recarregar a sessão do Zsh   zsh-autosuggestions sugere comandos enquanto você digita com base no histórico e nos “tab-completions”   zsh-syntax-highlighting fornece destaque de sintaxe    Você pode acessar https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins para ver uma lista completa dos plugins e suas respectivas documentações.\nOs dois últimos plugins da minha lista não fazem parte da instalação padrão do Oh-My-Zsh e devem ser instalados separadamente. Talvez seja possível instalá-los com o gerenciador de pacotes da sua distribuição, mas eu prefiro instalar via Github para tirar proveito de possíveis novos recursos.\nComo você está usando Oh-My-Zsh como um gerenciador de plug-ins, e os plug-ins já estão ativados em nosso arquivo .zshrc, tudo o que você precisa fazer é clonar o repositório do projeto direto no diretório $ZSH_CUSTOM.\nBasta digitar o seguinte comando para zsh-autosuggestions:\n git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n E o seguinte para zsh-syntax-highlighting:\n git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n Instalando uma fonte melhor Para obter um melhor suporte para ícones e símbolos, você deve instalar uma fonte moderna como a Nerd Fonts. Eu uso Meslo, mas você pode escolher a sua e testar.\nFonte Meslo Nerd\nAgora você precisa configurar o emulador de terminal para usar a fonte Meslo Nerd.\nTema do prompt, o Starship Para concluir a tarefa, o último passo é instalar o Starship, que trará muitas melhorias para o nosso shell Zsh. A instalação é muito simples, basta digitar:\n o pacote curl deve estar instalado.   curl -fsSL https://starship.rs/install.sh | zsh\n Uma vez instalado, você precisa habilitá-lo. Basta colocar a seguinte linha no final ~/.zshrc\n eval “$ (starship init zsh)”\n É uma boa ideia comentar a linha ZSH_THEME no ~/.zshrc\nConfigurando Starship A configuração do Starship é de fácil entendimento. Primeiro, você precisa criar o arquivo de starship.toml. Ele deve ser colocado em ~/.config:\n mkdir -p ~/.config \u0026\u0026 touch ~/.config/starship.toml\n Depois disso, você deve preencher o arquivo com as opções que deseja alterar a configuração padrão. A propósito, a configuração padrão é bem legal! Como a configuração é um arquivo .toml, todas as opções são do tipo chave : valor.\nAs informações detalhadas sobre cada opção estão bem descritas na documentação oficial. Vou deixar aqui o que estou usando para servir como referência para você.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167  add_newline = true prompt_order = [ \"username\", \"memory_usage\", \"hostname\", \"kubernetes\", \"directory\", \"git_branch\", \"git_commit\", \"git_state\", \"git_status\", \"hg_branch\", \"package\", \"dotnet\", \"elixir\", \"elm\", \"golang\", \"haskell\", \"java\", \"nodejs\", \"php\", \"python\", \"ruby\", \"rust\", \"terraform\", \"nix_shell\", \"conda\", \"aws\", \"env_var\", \"crystal\", \"line_break\", \"battery\", \"cmd_duration\", \"jobs\", \"time\", \"character\", ] [battery] full_symbol = \"🔋\" charging_symbol = \"⚡️\" discharging_symbol = \"💀\" [[battery.display]] threshold = 10 style = \"bold red\" [[battery.display]] threshold = 60 style = \"bold yellow\" [[battery.display]] threshold = 100 style = \"bold green\" [character] # symbol = \"➜\" error_symbol = \"✗\" use_symbol_for_status = true [cmd_duration] min_time = 500 prefix = \"tooks \" [directory] truncation_length = 6 truncate_to_repo = true prefix = \"in \" style = \"bold cyan\" disabled = false # [env_var] # variable = \"SHELL\" # default = \"Zsh\" # prefix = \"\u003c\" # suffix = \"\u003e\" [git_branch] # symbol = \"🌱 \" truncation_length = 8 truncation_symbol = \"...\" style = \"bold purple\" disabled = false [git_state] cherry_pick = \"CHERRY PICKING\" rebase = \"REBASING\" merge = \"MERGING\" revert = \"REVERTING\" bisect = \"BISECTING\" am = \"AM\" am_or_rebase = \"AM/REBASE\" progress_divider = \" of \" style = \"bold yellow\" disabled = false # [git_status] # conflicted = \"🏳\" # ahead = \"🏎💨\" # behind = \"😰\" # diverged = \"😵\" # untracked = \"🤷‍\" # stashed = \"📦\" # modified = \"📝\" # staged.value = \"++\" # staged.style = \"green\" # staged_count.enabled = true # staged_count.style = \"green\" # renamed = \"👅\" # deleted = \"🗑\" # [[git_status.count]] # enabled = true [hostname] ssh_only = false prefix = \"🤖\" # suffix = \"⟫\" trim_at = \".\" disabled = false # [jobs] # symbol = \"+ \" # threshold = 1 [line_break] disabled = false # [memory_usage] # disabled = false # show_percentage = true # show_swap = false # threshold = -1 # symbol = \" \" # separator = \"/\" # style = \"bold dimmed white\" [nodejs] symbol = \"⬢ \" style = \"bold green\" disabled = false # [package] # symbol = \"📦 \" # style = \"bold red\" # disabled = false [python] symbol = \"🐍 \" pyenv_version_name = false pyenv_prefix = \"pyenv\" style = \"bold yellow\" disabled = false # [time] # format = \"🕙%T\" # style_root = \"bold red\" # style_user = \"bold yellow\" # show_always = true # disabled = false [username] style_root = \"bold red\" style_user = \"bold yellow\" show_always = false disabled = false   Agora basta fechar seu terminal e abrir novamente para ver o resultado. Gostou?! 😉\nEspero que seja realmente útil para você e agradeço por ter lido!\n","description":"","subtitle":"Melhorando a produtividade","tags":["linux","shell","bash","zsh"],"title":"Instalando Zsh + Oh-My-Zsh + Starship","uri":"/pt-br/posts/zsh+oh-my-zsh+starship/"},{"categories":null,"content":"Essa é a parte mais complexa de subir um site. 😄\nCriei esse blog para servir de documentação para os aprendizados do dia a dia e para poder retribuir um pouco de tudo que já aprendi nos muitos artigos e tutoriais que li durante vários anos.\nCom relação à carreira, entrei bem tarde na área de TI, mas estou sempre estudando para ampliar meu campo de atuação.\nEm 2017, um tempo após me formar em Ciência da Computação, passei num concurso público para área técnica de informática. Estou trabalhando lá atualmente.\nA parte boa é que, como a equipe é bem pequena, fazemos de tudo um pouco. Infraestrutura, desenvolvimento, segurança. Sei que não é o ideal, mas fazer o que, é o que temos! 😅\nAtualmente estou me dedicando a aprender Python e JavaScript de verdade. Ando lendo bastante sobre Docker também.\nEnfim, sou um cara apaixonado por Linux e Open Source, Heavy Metal e futebol.\n","description":"","tags":null,"title":"About","uri":"/pt-br/about/"},{"categories":["tutoriais"],"content":"Olá, bem-vindo ao meu blog!\nNesse artigo irei mostrar como rodar o Arch Linux ARM no Raspberry Pi 4.\nCreio que todos já conhecem o Raspberry Pi, mas caso ainda não tenha ouvido falar sobre ele, clique aqui.\nAgora que já sabe do que se trata, vamos ao que interessa. Vale ressaltar que boa parte desse guia se encontra nas instruções na página do próprio projeto, disponível aqui.\nA primeira coisa a fazer é formatar o seu cartão MicroSD. Recomendo um bom cartão Classe 10 ou melhor.\nA ferramenta para particionamento é de livre escolha. Utilizarei o fdisk que está disponível por padrão na maioria das distribuições Linux.\n Primeiro iniciamos o microSD com o fdisk. Você precisa utilizar sudo ou realizar o processo como root.  fdisk /dev/sdX\n   Substitua o “X” pelo identificador do seu MicroSD.\nNo primeiro prompt, apague (!!!) as partições e crie uma nova:    Tecle o e ENTER. Isso vai limpar as partições atuais.\n  Tecle p para listar as partições. Não deve haver nenhuma listada.\n  Tecle n e ENTER para uma nova partição e p para escolher o tipo “Primária”. Agora 1 para a primeira partição e ENTER para aceitar o valor padrão para o primeiro setor. Agora digite +100M para o último setor.\n  Tecle t e então c para configurar a primeira partição com o tipo W95 FAT32 (LBA)\n  Agora tecle n para uma nova partição e p novamente para “Primária”. E então 2 para segunda partição no cartão e pressione ENTER duas vezes para aceitar os valores padrão para primeiro e último setores da segunda partição.\n  Pressione w para escrever a tabela de partições e sair.\n  Dessa maneira você garante o restante do cartão para o sistema. Falaremos disso mais adiante.\n Crie e monte o sistema de arquivos FAT que abrigará os arquivos de boot:\n mkfs.vfat /dev/sdX1\nmkdir boot\nmount /dev/sdX1 boot\n   Crie e monte o sistema de arquivos EXT4 que abrigará o sistema:\n mkfs.ext4 /dev/sdX2\nmkdir root\nmount /dev/sdX2 root\n   Baixe e extraia o sistema de arquivos raiz (root filesystem). Os parâmetros do comando bsdtar são: x para extrair, p para restaurar as permissões e f indica o arquivo de entrada. O C após o arquivo de entrada indica o diretório para o qual deveremos mudar antes de extrair os arquivos, no caso caso, o diretório root que criamos.\nEssa parte deve, obrigatoriamente, ser feita como usuário root:\n wget http://os.archlinuxarm.org/os/ArchLinuxARM-rpi-4-latest.tar.gz\nbsdtar -xpf ArchLinuxARM-rpi-4-latest.tar.gz -C root\nsync\n   Aqui vai uma dica: a URL informada na documentação apresentou um erro no dia que tentei fazer o download. Fui direto para o mirror do Brasil e descobri que estava desatualizado, aproveitei e reportei no IRC #archlinux-arm. Consegui baixar a última versão recorrendo diretamente ao mirror dinamarquês. Uma lista de mirrors está disponível em: https://archlinuxarm.org/about/mirrors\n Mova os arquivos de boot para a primeira partição:\n mv root/boot/* boot\n   Desmonte as duas partições:\n umount boot root\n   Insira o cartão no Raspberry Pi, conecte o cabo ethernet e a fonte de energia.\n  Caso não utilize o Raspberry Pi ligado diretamente a um vídeo, teclado e mouse, pode conectar via SSH. Verifique o IP atribuído pelo DHCP do seu roteador, por exemplo.\n Logue-se com o usuário padrão alarm e a senha alarm. A senha padrão de root é root.    Por último, mas não menos importante: Inicialize o chaveiro do Pacman e popule com as chaves do Arch Linux ARM.\n pacman-key --init\npacman-key --populate archlinuxarm\n   Pronto, o Arch Linux ARM já está pronto para ser utilizado para o projeto que quiser. Recomendo atualizar o sistema e reiniciar para começar a brincadeira.\n pacman -Syu\nsystemctl reboot\n Nos próximos posts falaremos mais sobre configurações e utilização do sistema. Até mais.\n","description":"","subtitle":"Mantendo as coisas simples 😃","tags":["linux","raspberrypi","arm","archlinux"],"title":"Arch linux ARM no Raspberry Pi 4","uri":"/pt-br/posts/arch_linux_arm-raspberry_pi_4/"}]
