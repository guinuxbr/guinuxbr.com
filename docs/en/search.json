[{"categories":["tutorials"],"content":"Hello, in this article, I’ll explain how to install openSUSE Tumbleweed (however, these instructions would probably work in openSUSE Leap) in Raspberry Pi 4, plus install and configure a basic Samba server to share files from an external HDD.\nThe first thing to do is install the openSUSE Tumbleweed image on your Raspberry Pi 4. Go to the openSUSE Wiki page for Raspberry Pi 4 and download the image that you like to use.\nThere are six images available. Download the image you want (Leap is stable, Tumbleweed is rolling) from here. Choose your desktop type:\n JeOS - Just enough Operating System - a very basic system, no graphical desktop E20 - Enlightenment desktop XFCE - XFCE desktop KDE - KDE desktop LXQT - LXQT desktop X11 - basic X11 system  The direct links did not work for me, so I went to the general download directory and downloaded the latest JeOS image named openSUSE-Tumbleweed-ARM-JeOS-raspberrypi.aarch64.raw.xz\nAs root extract the image onto your SD card or USB device(replace sdX with the device name of your SD card).\nIf possible, it is better to use a decent USB 3 device as the read and write speeds are greater than SD cards. I’ll use the USB device as the media used to install the image from now on.\nWARNING: this is a destructive operation. All previous data on the device will be lost. Check first if the device you have selected is really your target device!\n xzcat openSUSE-Tumbleweed-ARM-JeOS-raspberrypi.aarch64.raw.xz | dd bs=4M of=/dev/sdX iflag=fullblock oflag=direct status=progress; sync\n After the image is extracted to the USB device, you can insert it into your Raspberry Pi 4 and turn it on.\nYou will need to discover the IP address of your Raspberry Pi 4. This can be done in a hundred different ways. For example, you can look at your router DHCP table for a MAC address that belongs to “Raspberry Pi Trading Ltd”.\nWait 5 minutes before the first login as the OS will perform some tasks at the first boot, like resizing the ext4 filesystem to the entire disk.\nSSH is enabled by default in openSUSE images so that you can log in as root with:\n ssh root@raspberry_pi_ip_address\n The default password is “linux”.\nFind your keyboard layout and load it. To search your keyboard, type:\n localectl list-keymaps\n In my case, I use a Brazilian keyboard layout called “br-abnt2”. Load your keyboard layout with:\n loadkeys br-abnt2\n For security reasons, change the default root password.\n passwd\n Type once and then confirm your new password.\nCheck for available system updates.\n zypper dup --details\n Install vim and vim-data to have a better editing experience. You can use the editor that you prefer.\n zypper in --details --no-recommends vim vim-data\n Change the hostname as you like.\n hostnamectl hostname your_hostname\n Create your user account.\n useradd -m -s $(which bash) your_username\n Configure the sudo commands allowed for your account.\n visudo -f /etc/sudoers.d/your_username\n Add your_username ALL=(ALL) ALL to the file and save it.\nAs the server administrator, I’ll give my user account the right to run all commands as root.\nNow configure sudo to ask for your password instead of the root password.\n visudo\n Comment the following lines:\n1 2  Defaults targetpw # ask for the password of the target user i.e. root ALL ALL=(ALL) ALL # WARNING! Only use this together with 'Defaults targetpw'!   Check if is everything correct with your sudo related files.\n visudo -c\n If there is some problem, you can fix it by editing the file.\nSet a password for your user account.\n passwd your_username\n Reboot the system to be able to SSH with your user account instead of the root account.\n systemctl reboot\n Log in with your user account.\n ssh your_username@raspberry_pi_ip_address\n Now we will mount the external HDD to /mnt/externalhdd/\nFirst we discover the UUID for the external HDD.\n lsblk --fs --output UUID,TYPE,FSTYPE,LABEL,MOUNTPOINT\n 1 2 3 4 5 6 7 8 9  UUID TYPE FSTYPE LABEL MOUNTPOINT disk 30e471a2-263e-48c2-9d57-d32445b7038a part ext4 externalhdd disk 8511-418f part vfat EFI /boot/efi d1ed4b63-3e1a-4aa6-9e26-1e19fe9a77b0 part swap SWAP fd388969-253a-4709-8e23-5243f0eeb33d part ext4 ROOT / disk [SWAP]   Create the mount point.\n mkdir -p /mnt/externalhdd\n Edit the /etc/fstab file and add the line for the external HDD. Observe that in this case, the external HDD is formatted as ext4. Adjust according to your needs.\n1 2 3 4 5 6  # System mount point UUID=fd388969-253a-4709-8e23-5243f0eeb33d / ext4 noatime,nobarrier 0 1 # EFI partition mount point UUID=1845-7210 /boot/efi vfat defaults 0 0 # External HDD mount point UUID=30e471a2-263e-48c2-9d57-d32445b7038a /mnt/externalhdd ext4 noatime,nobarrier 0 2   Test the mount point.\n mount -a\n If everything worked correctly, you should see no output.\nNow you can install the Samba server.\n sudo zypper in --details --no-recommends samba samba-doc\n Backup the original Samba configuration file.\n sudo mv /etc/samba/smb.conf /etc/samba/smb.conf.bkp\n To better understand the options, copy a fully commented example file from the Samba documentation.\n sudo cp /usr/share/doc/packages/samba/examples/smb.conf.default /etc/samba/smb.conf\n In this article, other than users, I 'll use a group to control the access to the shared folders.\nAdd a group called smbusers or whatever you like.\n sudo groupadd smbusers\n Create a Samba password for the user that will have access to the shares. This password can be different from the user account password.\n sudo smbpasswd -a your_username\n Edit the Samba configuration file. For simplicity, I’ll omit some comments, but I strongly recommend reading the Samba documentation to properly understand the options.\n sudo vim /etc/samba/smb.conf\n Some considerations:\n All shares will require the Samba password. I’ll use your_username to illustrate a real user replace with a proper user name.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  # Global Settings [global] # workgroup = NT-Domain-Name or Workgroup-Name, eg: MIDEARTH workgroup = YOUR_WORKGROUP_NAME # server string is the equivalent of the NT Description field server string = Some string to identify your server # Server role.  server role = standalone server # Restrict access to your LAN network, and the \"loopback\" interface hosts allow = 192.168.0. 127. # Use a separate log file for each machine that connects log file = /var/log/samba/log.%m # Put a capping on the size of the log files (in Kb). max log size = 50 # Backend to store user information. passdb backend = tdbsam # DNS Proxy - tells Samba whether or not to try to resolve NetBIOS names via DNS nslookups. The default is NO. dns proxy = no # This one is useful for people to share files [tmp] comment = Temporary file space path = /mnt/externalhdd/tmp read only = no public = yes browsable = yes writable = yes # A private directory, usable only by your_username. Note that your_username requires write access to the directory. [username] comment = Private stuff for your_username path = /mnt/externalhdd/your_username valid users = your_username public = no writable = yes printable = no create mask = 0700 directory mask = 0700 # Custom shares # A share for pictures, accessible only by members of the group \"smbusers\" [pictures] comment = Pictures path = /mnt/externalhdd/pictures public = no browsable = yes writable = yes valid users = @smbusers   Test the Samba configuration file.\n testparm\n This final part enables the Firewall and allows the Samba ports through it.\n sudo systemctl enable --now firewalld.service\n In this case, we are using the “home” firewall zone and the interface “eth0”.\n sudo firewall-cmd --set-default-zone=home\nsudo firewall-cmd --zone=home --change-interface=eth0\n Allow the Samba service through the Firewall.\n sudo firewall-cmd --zone=home --permanent --add-service=samba\n Reload the firewall configuration.\n sudo firewall-cmd --reload\n Enable and start the smb and nmb services.\n sudo systemctl enable --now smb.service sudo systemctl enable --now nmb.service\n Reboot your Raspberry Pi, and you should have a working Samba server sharing your external HDD.\n sudo systemctl reboot\n ","description":"","subtitle":"Sharing files within your LAN","tags":["linux","raspberrypi","opensuse","arm","samba"],"title":"Raspberry Pi4 + openSUSE + Samba","uri":"/en/posts/raspberry_pi4+opensuse_tumbleweed+samba/"},{"categories":["tutorials","tips"],"content":"This article is about how to backup dotfiles using Git. I will try to keep it short and straightforward.\nI’m using Zsh as the shell in the examples, but other shell can be used. The commands below should be executed as a normal user in the /home directory.\nCreate a local Git repository that will be used to track the dotfiles.\n git init $HOME/.dotfiles\n The default behaviour of Git commands is to run inside the project folder using information stored at the \u003cproject\u003e/.git directory, and Git assumes that the working tree is located at \u003cproject\u003e. To enable the execution of Git commands specifically for the “dotfiles” repository from anywhere, it is needed to create an alias that indicates the location of the Git directory and the working tree.\n alias dotfiles=’/usr/bin/git --git-dir=$HOME/.dotfiles/.git --work-tree=$HOME'\n Make this alias permanent.\n echo “alias dotfiles=’/usr/bin/git --git-dir=$HOME/.dotfiles/.git --work-tree=$HOME’” » $HOME/.zsh/aliases\n Source the aliases file inside .zshrc file adding the following line.\n source $HOME/.zsh/aliases\n By default, Git will consider all the files under the working tree as untracked. To avoid this behaviour, configure Git to show only the files that are explicitly added.\n dotfiles config --local status.showUntrackedFiles no\n Add the files that you want to track, for example.\n dotfiles add .vimrc .zshrc .gitignore\n Link the local to the remote repository. The remote repository can be a GitHub or any other Git repository.\n dotfiles remote add origin remote-url\n Push the changes to the remote repository. This is effectively the backup of the dotfiles.\n dotfiles push -u origin main\n Now the dotfiles are backed up to the remote repository.\n","description":"","subtitle":"Or any other version control system","tags":["linux","git"],"title":"Backup dotfiles to GitHub","uri":"/en/posts/backup-and-restore-dot-files/"},{"categories":["tutorials","tips"],"content":"For a long time, I ran away from Vim because it seemed very tricky and because there is a lot of simpler editors out there to work with. However, as it comes installed in most Linux distributions, I made this cheat sheet to help me understand how things work. I have discovered that is possible to be very productive with Vim 😃.\nI’ll try to go straight to the point. This cheat-sheet is not intended to be a complete guide but it helps to get started.\nVim have different operation modes, and I will not cover all of them in this cheat sheet. I’ll stick with the basic functionality needed to open, edit and save a file.\nLet’s begin! To open a file with Vim just type vim filename.\nESC = enter “command mode”\nMove the cursor You can use the arrow keys to move the cursor around. There is also special keys to do this:\n h = move one character left j = move one row down k = move one row up l = move one character right  Edition Mode The following keys have to be typed in “Command Mode”.\n i = insert text in the cursor position I = insert text in the begin of the line o = insert text in the next line O = insert text in the previous line a = insert a character after the current A = insert text at the end of the line r = replace the character at the current cursor position R = enter replace mode to replace characters from the current cursor position u = undo last action CTRL + r = redo  Saving \u0026 Exiting The following keys have to be typed in “Command Mode”.\n :w = Save :q = Exit :q! = Force exit (exit without saving) :qa = Exit from all opened files :wq = Save and exit :x = Save and exit ZZ = Save and exit ZQ = Force exit (exit without saving)  Copy, paste \u0026 cut The following keys have to be typed in “Command Mode”.\n yy = copy line p = paste content to the below line P = paste content to the above line yNy = copy N lines cw = cut the word starting from the current cursor position dd = cut or delete a line D = delete the line starting from the current cursor position dG = delete the lines starting from the current cursor position to the end of the file dGG = delete the lines starting from the current cursor position to the begin of the file dw = delete the word starting from the current cursor position dNd = cut or delete N lines x = delete a character at the current cursor position (similar to “delete” key behaviour) X = delete a character before the current cursor position (similar to “backspace” key behaviour) yw = copy the word starting from the current cursor position  Visual Mode The following keys have to be typed in “Command Mode”.\n v = visual mode that allows to select a text fragment V = visual mode that allows to select an entire line CTRL+v = visual block that allows select a block of text  Navigation The following keys have to be typed in “Command Mode”.\n /pattern = search forward for a patter ?pattern = search backward for a pattern n = pattern forward search N = pattern backward search gg = goes to the first line of the file G = goes to the last line of the file H = goes to the top of the current screen M = goes to the middle of the current screen L = goes to the end of the current screen  Commands The following keys have to be typed in “Command Mode”.\n :set hlsearch = enable search highlight :set number = show line numbers :set tabstop=N = set the size of TAB to N :set expandtab = convert TAB in spaces :set bg=dark/light = change the color scheme :set ignorecase = makes the search case insensitive :syntax on/off = enable/disable syntax highlighting :LNs/tobereplaced/replacer/g = replaces(s) all(g) tobereplaced with replacer in the line LN :%s/tobereplaced/replacer/g = replaces(s) all(g) tobereplaced with replacer in the entire file :e filename = opens “filename” :r filename = copy the contents of the “filename” to the current file :split filename = split screen horizontally to show the current file and “filename” :vsplit filename = split screen vertically to show the current file and “filename” :! command = runs “command” in shell and show the STDOUT !! command = runs “command” in shell and paste the STDOUT in the file  ","description":"","subtitle":"Sooner or latter you will need it","tags":["linux","vim","editor"],"title":"Vim Cheat Sheet","uri":"/en/posts/vim-cheat-sheet/"},{"categories":["tutorials","tips"],"content":"Hi and welcome to my blog!\nKWallet is a KDE Plasma tool to store any credentials and secrets safely. It has an interface called KWallet Manager that allows to manage credentials and secrets easily.\nIn this quick tutorial, I’ll show how to configure your KDE to store your GitHub credentials in KWallet. This guide was tested against openSUSE Tumbleweed but should work for most Linux distributions.\nFirst, make sure to have ksshaskpass installed. ksshaskpass is an ssh-add helper that uses kwallet and kpassworddialog to show a window where you should type your credentials.\nNow, create an autostart script file and mark it as executable:\n touch ~/.config/plasma-workspace/env/askpass.sh\n Open it for edition.\n nano ~/.config/plasma-workspace/env/askpass.sh\n Put the following content in the file:\n1 2  #!/bin/sh export GIT_ASKPASS='/usr/lib/ssh/ksshaskpass'   Save and exit. Now make it executable.\n chmod +x ~/.config/plasma-workspace/env/askpass.sh\n Next time you log in, open Konsole and try to clone some of your private GitHub repositories. If your wallet is already open and you will see the ksshaskpass dialogue asking for your user name and then asking for your password. Just make sure to mark “Remember password” in both dialogues to save your credentials safely in your wallet.\n","description":"","subtitle":"Konsole + GitHub + KWallet","tags":["linux","kde","opensuse"],"title":"Secure GitHub credentials with KWallet","uri":"/en/posts/secure-git-credentials-kwallet/"},{"categories":["tutorials"],"content":"Hi and welcome to my blog! Here goes a quick tip on how to properly sort partitions number in Linux.\nLet’s think that we had a disk /dev/sda with 4 partitions:\n/dev/sda1 /dev/sda2 /dev/sda3 /dev/sda4  Now, if we have to repartition our disk and delete /dev/sda2 and /dev/sda3 to make /dev/sda1 larger, occasionally you will end up with /dev/sda1 and /dev/sda4 when it should be only /dev/sda1 and /dev/sda2.\nTo fix this mess and sort the partitions correctly we can use fdisk that is present by default in almost every Linux installation. Remember that fdisk and most of the partition/disk tools are very powerful and can be dangerous. Make sure to have a backup of your important files.\nNow, let’s do the job. Begin typing sudo fdisk /dev/sda.\nThan type “m” to see the help.\nPress “p” to print the partitions list.\nYou’ll see that they are unsorted.\nNow, type “x” to access the advanced options.\nThan type “m” again to see the help.\npress “f” to fix partitions order.\npress “p” again to print the partitions list.\nNow, they should be sorted correctly 😉.\nPress “w” to write changes to disk and exit.\nIt’s done.\n","description":"","subtitle":"Fix the partition mess","tags":["linux","partitions"],"title":"Sort Linux partitions correctly","uri":"/en/posts/sort-linux-partitions-correctly/"},{"categories":["tutorials"],"content":"Hello and welcome to my blog.\nWe use Windows in our workstations at my current job (it was not my choice 🙊), but there is a lot of tasks that are easier to do in a Linux environment. Some days ago I needed to manipulate a huge CSV and just thought: “This would be a lot simple with cat, grep, sort, etc.”.\nSo, I remember that I have read something about running Linux inside Windows using WSL and, well, why not give a try?\nSetting up the environment Some considerations:\n WSL 2 is only available in Windows 10, Version 2004, Build 19041 or higher. Check your Windows version by selecting the Windows logo key + R, type winver, select OK. All Windows commands should be typed in a PowerShell session with administrative privileges unless otherwise specified (right-click in the PowerShell icon and choose “Run as administrator”).  Here we go! Since I’m a command-line lover and do not have a Microsoft account to access Microsoft Store, I’ll do this from there as much as possible. First, let’s install a decent terminal emulator and Microsoft is doing a good job with Windows Terminal. I have downloaded v1.1.2021.0 and renamed it to WindowsTerminal.msixbundle. This is the latest version at the time of writing. The installation is pretty straight forward, just open a PowerShell instance, navigate to the directory where the executable was downloaded and type:\n .\\WindowsTerminal.msixbundle\n Now, click in Instal and wait a few seconds to the windows of Windows Terminal show up. Close this window for now, we need to open it as Administrator soon.\nThe next step is to enable WSL. Use the same method stated at the top of the article to launch an instance of Windows Terminal with administrative privileges (damn, I wish that there was a “sudo” for this. Maybe Microsoft can launch an “addo” 🙃). Observe that should have a “PS” before your prompt, this indicates that you are in a PowerShell session. Now type:\n dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n The ‘Virtual Machine Platform’ is needed to run WSL 2. To enable it, just type:\n dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n You should see “The operation completed successfully.” to both commands. Now reboot your computer.\nOnce rebooted, open Windows Terminal again and set WSL2 as default:\n wsl --set-default-version\n If you already have a distribution installed and like to convert it to use WSL2, this is possible. First, check the current status.\n wsl --list --verbose\n The above command will show a list of installed distributions separated by NAME, STATE, and VERSION. For instance, if you have an Ubuntu installation that is running at version 1 you can type:\n wsl --set-version Ubuntu 2\n You also can revert it to WSL 1 if you are not satisfied with the result, just change the version number.\nDownload and installation Now it is time to download the distribution that you wish to install. I chose Debian because it is very light and stable. Since Windows 10 Spring 2018 Update, curl.exe is present, so let’s use it.\n curl.exe -L -o debian.appx https://aka.ms/wsl-debian-gnulinux\n The installation step is also quite simple.\n Add-AppxPackage .\\debian.appx\n A strange progress bar will be displayed. Once it disappears, it is done. Now Debian should be available in your applications menu, but don’t click there, use the Windows Terminal do open a Debian session. On the right side of the tab, there is an arrow that hides all the possible sessions. Clicking on Debian will lead you to the user configuration screen. Choose your username and password and you are done.\nConfiguration Now, I recommend that you update installation:\n sudo apt update \u0026\u0026 sudo apt upgrade\n Verify the version of Debian that was installed.\n cat /etc/os-release\n For an unknown reason by me, the downloaded image was still the Stretch version of Debian. No problem, let’s update it to Debian Buster. First, make a backup of your sources.list file.\n sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\n Now, replace every “stretch” entry with “buster”. You can do this with nano or vi or directly with sed.\n sudo sed -i ’s/stretch/buster/g’ /etc/apt/sources.list\n Then update the system again.\n sudo apt update \u0026\u0026 sudo apt upgrade \u0026\u0026 sudo apt full-upgrade\n Now get rid of obsolete packages in your system.\n sudo apt autoremove\n Close the Debian tab and open another one to check if you have installed Debian Buster with success.\n cat /etc/os-release\n You should see something like the below:\nPRETTY_NAME=\"Debian GNU/Linux 10 (buster)\" NAME=\"Debian GNU/Linux\" VERSION_ID=\"10\" VERSION=\"10 (buster)\" VERSION_CODENAME=buster ID=debian HOME_URL=\"https://www.debian.org/\" SUPPORT_URL=\"https://www.debian.org/support\" BUG_REPORT_URL=\"https://bugs.debian.org/\" Final considerations For a better file system performance, make sure to store your Linux project files in the Linux file system (not the Windows file system). It is probable that when you open a Debian session your prompt show something like: username@hostname:/mnt/c/Users/username$ This is why WSL exposes the Windows file system through mount points placed in /mnt like /mnt/c and /mnt/d just type cd ~ to go to your real home.\nNot only the file system of Windows is exposed by WSL, but you can use Windows applications too, try to type explorer.exe . As you can see, Windows Explorer will open with the files of your current directory loaded.\nThat is it, everything is set up and ready to use.\n","description":"","subtitle":"Useful and cool","tags":["linux","wsl","wsl2","windows"],"title":"Run Debian in Windows 10 with WSL 2","uri":"/en/posts/debian-windows10-wsl2/"},{"categories":["tutorials"],"content":"Hello! In this quick tutorial, I will show you how to convert OVA file to a QCOW2.\nA few days ago I have to install Windows in a virtual environment to test some stuff. Then, I found that Microsoft provides some test images officially at https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/ but there are no images to use with KVM. So, what if it would be possible to convert some of the provided formats to a KVM compatible format?\nWell, this is possible and much easier than I thought it was. Follow me!\nFirst, we have to extract the files from the OVA file.\n tar -xvf MSEdge-Win10.ova\n An OVA file is an Open Virtualization Appliance that contains a compressed version of a virtual machine. Now we have two files: the MSEdge - Win10-disk001.vmdk and the MSEdge - Win10.ovf. To convert the .vmdk file to a .qcow2 file to import into KVM we just have to use the qemu-img command as follows.\n qemu-img convert MSEdge-Win10-disk001.vmdk the_name_you_want.qcow2 -O qcow2\n Observe that I’ve renamed the file MSEdge - Win10-disk001.vmdk to remove the blank spaces. I always try to do this before work with files in the command line.\nThat’s it! Now we can just move our converted the_name_you_want.qcow2 to the images directory that is usually /var/lib/libvirt/images, but you can place it wherever you wish and import it.\n","description":"","subtitle":"Easy way to use in KVM","tags":["linux","virtualization"],"title":"Convert OVA to QCOW2","uri":"/en/posts/convert-ova-to-qcow2/"},{"categories":["tutorials"],"content":"Hello, welcome to my blog!\nIn this article, I will show you how to run Arch Linux ARM on the Raspberry Pi 4.\nI think everyone already knows the Raspberry Pi, but if you haven’t heard about it, click here.\nNow that you know what it is about, let’s get down to business. It is worth mentioning that a good part of this guide is found in the instructions on the project’s own page, available here.\nThe first thing to do is to format your MicroSD card. I recommend a good Class 10 card or better.\nThe choice of the partitioning tool is up to you. I will use fdisk which is available by default on most Linux distributions.\n First, we start microSD with fdisk. You need to use sudo or perform the process as root.  fdisk / dev / sdX\n   Replace “X” with your MicroSD identifier.\nAt the first prompt, delete (!!!) the partitions and create a new one:    Press o and ENTER. This will clear the current partitions.\n  Press p to list the partitions. There should be none listed.\n  Press n and ENTER for a new partition and p to choose the “Primary” type. Now 1 for the first partition and ENTER to accept the default value for the first sector. Now type + 100M for the last sector.\n  Press t and then c to configure the first partition with type W95 FAT32 (LBA)\n  Now press n for a new partition and p again for “Primary”. Then 2 for the second partition on the card and press ENTER twice to accept the default values ​​for the first and last sectors of the second partition.\n  Press w to write the partition table and exit.\n  This way you guarantee the rest of the card to the system. We will talk about this later.\n Create and mount the FAT file system that will be filled by the boot files:\n mkfs.vfat / dev / sdX1 mkdir boot mount / dev / sdX1 boot\n   Create and mount the EXT4 file system that will be filled by the system files:\n mkfs.ext4 / dev / sdX2 mkdir root mount / dev / sdX2 root\n   Download and extract the root filesystem. The parameters of the bsdtar command are: x to extract, p to restore permissions, and f indicates the input file. The C after the input file indicates the directory to which we must change before extracting the files, in this case, the root directory we have created. This part MUST be done as the root user:\n wget http://os.archlinuxarm.org/os/ArchLinuxARM-rpi-4-latest.tar.gz bsdtar -xpf ArchLinuxARM-rpi-4-latest.tar.gz -C root sync\n   Here’s a tip: the URL reported in the documentation had an error the day I tried to download it. I went straight to the mirror in Brazil and found it was out of date, took advantage, and reported on IRC # archlinux-arm. I managed to download the latest version using the Danish mirror directly. A list of mirrors is available at https://archlinuxarm.org/about/mirrors\n Move the boot files to the first partition:\n mv root/boot/* boot\n   Unmount the two partitions:\n umount boot root\n   Insert the card into the Raspberry Pi, connect the ethernet cable and the power supply.\n  If you do not use the Raspberry Pi connected directly to a video, keyboard, and mouse, you can connect via SSH. Check the IP assigned by your router’s DHCP, for example. * Log in with the standard user alarm and password alarm. * The default root password is root.\n  Last, but not least: Start the Pacman keychain and populate it with the Arch Linux ARM keys.\n pacman-key -- init pacman-key -- populate archlinuxarm\n   Ready, Arch Linux ARM is ready to be used for the project you want. I recommend updating the system and restarting to start the game.\n pacman -Syu systemctl reboot\n In the next posts, we will talk more about configurations and the use of the system. See you.\n","description":"","subtitle":"Keeping the things simple!","tags":["linux","raspberrypi","arm","archlinux"],"title":"Arch linux ARM on Raspberry Pi 4","uri":"/en/posts/arch_linux_arm-raspberry_pi_4/"},{"categories":["tutorials","productivity"],"content":"Update: Starship configurarion changed in the newer versions. This article was updated and covers the version 1.3.0.\nHi, welcome to my blog!\nThe objective of this article is to share my shell setup with you. I think that my job and day to day tasks became easier and more productive than using the “normal” bash. I hope that it helps you.\nYou will need the following tools:\nZsh - The Z shell.\nOh-My-Zsh - A framework for managing your Zsh configuration.\nStarship - A fast and customizable prompt for any shell!\nI assume that you already have git installed and have a little knowledge of using it to clone repositories.\nInstalling Zsh First, you need to install Zsh. You can use your distribution package manager to install it easily.\nFor openSUSE:\n sudo zypper install zsh\n For Ubuntu:\n sudo apt install zsh\n For Fedora:\n sudo dnf install zsh\n After this you should set Zsh as your default shell:\n chsh -s $(which zsh)\n Now reboot your machine.\nInstalling Oh-My-Zsh After rebooting, open your terminal and you should now be prompted by a Zsh configuration wizard. At this time you can just type q and ENTER because you will install and configure Oh-My-Zsh and it will install a .zshrc template for us:\n curl or wget should be installed. git should be installed.   sh -c “$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)”\n If Oh-My-Zsh was successfully installed, you should see that your prompt changes to a green one. The template configuration file is ~/.zshrc and it gives you tons of possibilities to configure your shell behavior, like prompt themes and plugins.\nLoading some plugins There is a lot of configurations that can be made in Zsh + Oh-My-Zsh, here I’ll just talk about a list of cool plugins that I use, but you can dive deeper to discover more possibilities. Plugins should be placed in plugins=(...) session of the configuration file. I use the following:\n   plugin name brief description     colored-man-pages adds colors to man pages   command-not-found uses the command-not-found package for Zsh to provide suggested packages   docker adds auto-completion for docker   git provides many aliases and a few useful functions   npm provides completion as well as adding many useful aliases   pep8 adds completion for pep8   pip adds completion for pip   pyenv loads pyenv and pyenv-virtualenv   python adds several aliases for useful python commands   sudo prefix your current or previous commands with sudo by pressing esc twice   systemd provides many useful aliases for systemd   ubuntu This plugin adds completions and aliases for Ubuntu   zsh_reload type src to reload Zsh session   zsh-autosuggestions suggests commands as you type based on history and completions   zsh-syntax-highlighting package provides syntax highlighting    You can always go to https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins to see a complete list of plugins and their respective documentation.\nThe last two plugins of my list aren’t part of the default Oh-My-Zsh installation and should be installed separately. Maybe you can install it with your distribution package manager, but I do prefer to install via Github to take advantage of possible new features.\nAs you are using Oh-My-Zsh as a plugin manager, and the plugins are already enabled in our .zshrc file, all you have to do is clone the project repository to our $ZSH_CUSTOM directory. Just type the following commands. For zsh-autosuggestions:\n git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n And for zsh-syntax-highlighting:\n git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n Installing a better font For better support icons and symbols, you have to install a modern font like Nerd Fonts. I use the Meslo, but you can choose your own and test it.\n Meslo Nerd Fonts  Now you have to configure your terminal emulator to use Meslo Nerd Fonts.\nTheming the prompt with Starship To finish the task, the last step is to install Starship that will bring a lot of goodies to our Zsh shell. The installation is very simple, just type:\n curl should be installed.   curl -fsSL https://starship.rs/install.sh | zsh\n Once installed, you have to enable it. Just place the following line at the end ~/.zshrc\n eval “$(starship init zsh)”\n It is a good idea to comment out the ZSH_THEME entry in ~/.zshrc\nConfiguring Starship The configuration of Starship is easy to understand. First, you need to create de starship.toml file. It should be placed inside ~/.config:\n mkdir -p ~/.config \u0026\u0026 touch ~/.config/starship.toml\n After this, you have to fill the file with the options that you wish to change the default setup. By the way, the default setup is quite cool! As the configuration is a .toml file, all the options are of the type key : value, pretty intuitive.\nThe detailed information about every option is well described at the official documentation. However, I paste the one that I’m using to serve as a reference for you.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  # Inserts a blank line between shell prompts add_newline = true # Customizing the prompt format = \"\"\" $username\\ $hostname\\ $shlvl\\ $singularity\\ $kubernetes\\ $directory\\ $vcsh\\ $git_branch\\ $git_commit\\ $git_state\\ $git_metrics\\ $git_status\\ $hg_branch\\ $docker_context\\ $package\\ $cmake\\ $cobol\\ $dart\\ $deno\\ $dotnet\\ $elixir\\ $elm\\ $erlang\\ $golang\\ $helm\\ $java\\ $julia\\ $kotlin\\ $lua\\ $nim\\ $nodejs\\ $ocaml\\ $perl\\ $php\\ $pulumi\\ $purescript\\ $python\\ $rlang\\ $red\\ $ruby\\ $rust\\ $scala\\ $swift\\ $terraform\\ $vlang\\ $vagrant\\ $zig\\ $nix_shell\\ $conda\\ $memory_usage\\ $aws\\ $gcloud\\ $openstack\\ $azure\\ $env_var\\ $crystal\\ $custom\\ $sudo\\ $cmd_duration\\ $line_break\\ $jobs\\ $battery\\ $time\\ $status\\ $shell\\ [$character](bold green)\"\"\" # Configure if and how the time is shown [time] disabled = false time_format = \"%T\" format = \"🕙[$time ](bold blue)\" [sudo] disabled = false style = \"bold green\" symbol = \"💪\" format = \"[\u003cSUDO\u003e$symbol]($style)\" [status] disabled = false style = \"bg:blue\" symbol = \"🔴\" map_symbol = true format = '[\\[$symbol $common_meaning$signal_name$maybe_int\\]]($style) '   Close and reopen your terminal to see the results. Cool! Isn’t it?!\nThat’s it! I hope this article can be useful. Thanks for reading!\n","description":"","subtitle":"Increasing productivity","tags":["linux","shell","bash","zsh"],"title":"Installing Zsh + Oh-My-Zsh + Starship","uri":"/en/posts/zsh+oh-my-zsh+starship/"}]
