[{"categories":["tutorials"],"content":"This quick tip was tested on openSUSE Tumbleweed. However, it will probably work for other Linux distributions running KDE Plasma.\nInstall ksshaskpass5 via Zypper.\nsudo zypper in --details ksshaskpass5\nCreate the .desktop file that will be automatically parsed at KDE Plasma start-up. Add all the needed keys using ssh-add -q. The ‚Äúq‚Äù here stands for quiet.\nvim ~/.config/autostart/ssh-add.desktop\n1 2 3 4 5 6 [Desktop Entry] Exec=ssh-add -q /home/user_name/.ssh/key1 /home/user_name/.ssh/key2 \u003c /dev/null Icon=dialog-scripts Name=ssh-add.sh Type=Application X-KDE-AutostartScript=true For the Exec command, I‚Äôve used the /home/user_name/ path because ~ or $HOME did not work as expected.\nCreate another script in ~/.config/plasma-workspace/env/ to set the environment variable SSH_ASKPASS to use ksshaskpass.\nvim ~/.config/plasma-workspace/env/ksshaskpass.sh\n1 2 #!/bin/sh export SSH_ASKPASS='/usr/libexec/ssh/ksshaskpass' Now reboot the machine. In the next login, a dialogue window asking for your SSH key password will appear for each added key.\nEnsure to mark the option ‚ÄúRemember password‚Äù.\n","description":"","subtitle":"Automatically add SSH keys after log in","tags":["linux","kde","opensuse"],"title":"Load SSH keys via Kwallet","uri":"/en/posts/load-ssh-keys-kwallet/"},{"categories":["tutorials"],"content":"Hello, in this article, I‚Äôll explain how to install openSUSE Tumbleweed (however, these instructions would probably work in openSUSE Leap) in Raspberry Pi 4, plus install and configure a basic Samba server to share files from an external HDD.\nThe first thing to do is install the openSUSE Tumbleweed image on your Raspberry Pi 4. Go to the openSUSE Wiki page for Raspberry Pi 4 and download the image that you like to use.\nThere are six images available. Download the image you want (Leap is stable, Tumbleweed is rolling) from here. Choose your desktop type:\nJeOS - Just enough Operating System - a very basic system, no graphical desktop E20 - Enlightenment desktop XFCE - XFCE desktop KDE - KDE desktop LXQT - LXQT desktop X11 - basic X11 system The direct links did not work for me, so I went to the general download directory and downloaded the latest JeOS image named openSUSE-Tumbleweed-ARM-JeOS-raspberrypi.aarch64.raw.xz\nAs root extract the image onto your SD card or USB device(replace sdX with the device name of your SD card).\nIf possible, it is better to use a decent USB 3 device as the read and write speeds are greater than SD cards. I‚Äôll use the USB device as the media used to install the image from now on.\nWARNING: this is a destructive operation. All previous data on the device will be lost. Check first if the device you have selected is really your target device!\nxzcat openSUSE-Tumbleweed-ARM-JeOS-raspberrypi.aarch64.raw.xz | dd bs=4M of=/dev/sdX iflag=fullblock oflag=direct status=progress; sync\nAfter the image is extracted to the USB device, you can insert it into your Raspberry Pi 4 and turn it on.\nYou will need to discover the IP address of your Raspberry Pi 4. This can be done in a hundred different ways. For example, you can look at your router DHCP table for a MAC address that belongs to ‚ÄúRaspberry Pi Trading Ltd‚Äù.\nWait 5 minutes before the first login as the OS will perform some tasks at the first boot, like resizing the ext4 filesystem to the entire disk.\nSSH is enabled by default in openSUSE images so that you can log in as root with:\nssh root@raspberry_pi_ip_address\nThe default password is ‚Äúlinux‚Äù.\nFind your keyboard layout and load it. To search your keyboard, type:\nlocalectl list-keymaps\nIn my case, I use a Brazilian keyboard layout called ‚Äúbr-abnt2‚Äù. Load your keyboard layout with:\nloadkeys br-abnt2\nFor security reasons, change the default root password.\npasswd\nType once and then confirm your new password.\nCheck for available system updates.\nzypper dup --details\nInstall vim and vim-data to have a better editing experience. You can use the editor that you prefer.\nzypper in --details --no-recommends vim vim-data\nChange the hostname as you like.\nhostnamectl hostname your_hostname\nCreate your user account.\nuseradd -m -s $(which bash) your_username\nConfigure the sudo commands allowed for your account.\nvisudo -f /etc/sudoers.d/your_username\nAdd your_username ALL=(ALL) ALL to the file and save it.\nAs the server administrator, I‚Äôll give my user account the right to run all commands as root.\nNow configure sudo to ask for your password instead of the root password.\nvisudo\nComment the following lines:\n1 2 Defaults targetpw # ask for the password of the target user i.e. root ALL ALL=(ALL) ALL # WARNING! Only use this together with 'Defaults targetpw'! Check if is everything correct with your sudo related files.\nvisudo -c\nIf there is some problem, you can fix it by editing the file.\nSet a password for your user account.\npasswd your_username\nReboot the system to be able to SSH with your user account instead of the root account.\nsystemctl reboot\nLog in with your user account.\nssh your_username@raspberry_pi_ip_address\nNow we will mount the external HDD to /mnt/externalhdd/\nFirst we discover the UUID for the external HDD.\nlsblk --fs --output UUID,TYPE,FSTYPE,LABEL,MOUNTPOINT\n1 2 3 4 5 6 7 8 9 UUID TYPE FSTYPE LABEL MOUNTPOINT disk 30e471a2-263e-48c2-9d57-d32445b7038a part ext4 externalhdd disk 8511-418f part vfat EFI /boot/efi d1ed4b63-3e1a-4aa6-9e26-1e19fe9a77b0 part swap SWAP fd388969-253a-4709-8e23-5243f0eeb33d part ext4 ROOT / disk [SWAP] Create the mount point.\nmkdir -p /mnt/externalhdd\nEdit the /etc/fstab file and add the line for the external HDD. Observe that in this case, the external HDD is formatted as ext4. Adjust according to your needs.\n1 2 3 4 5 6 # System mount point UUID=fd388969-253a-4709-8e23-5243f0eeb33d / ext4 noatime,nobarrier 0 1 # EFI partition mount point UUID=1845-7210 /boot/efi vfat defaults 0 0 # External HDD mount point UUID=30e471a2-263e-48c2-9d57-d32445b7038a /mnt/externalhdd ext4 noatime,nobarrier 0 2 Test the mount point.\nmount -a\nIf everything worked correctly, you should see no output.\nNow you can install the Samba server.\nsudo zypper in --details --no-recommends samba samba-doc\nBackup the original Samba configuration file.\nsudo mv /etc/samba/smb.conf /etc/samba/smb.conf.bkp\nTo better understand the options, copy a fully commented example file from the Samba documentation.\nsudo cp /usr/share/doc/packages/samba/examples/smb.conf.default /etc/samba/smb.conf\nIn this article, other than users, I 'll use a group to control the access to the shared folders.\nAdd a group called smbusers or whatever you like.\nsudo groupadd smbusers\nCreate a Samba password for the user that will have access to the shares. This password can be different from the user account password.\nsudo smbpasswd -a your_username\nEdit the Samba configuration file. For simplicity, I‚Äôll omit some comments, but I strongly recommend reading the Samba documentation to properly understand the options.\nsudo vim /etc/samba/smb.conf\nSome considerations:\nAll shares will require the Samba password. I‚Äôll use your_username to illustrate a real user replace with a proper user name. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 # Global Settings [global] # workgroup = NT-Domain-Name or Workgroup-Name, eg: MIDEARTH workgroup = YOUR_WORKGROUP_NAME # server string is the equivalent of the NT Description field server string = Some string to identify your server # Server role. server role = standalone server # Restrict access to your LAN network, and the \"loopback\" interface hosts allow = 192.168.0. 127. # Use a separate log file for each machine that connects log file = /var/log/samba/log.%m # Put a capping on the size of the log files (in Kb). max log size = 50 # Backend to store user information. passdb backend = tdbsam # DNS Proxy - tells Samba whether or not to try to resolve NetBIOS names via DNS nslookups. The default is NO. dns proxy = no # This one is useful for people to share files [tmp] comment = Temporary file space path = /mnt/externalhdd/tmp read only = no public = yes browsable = yes writable = yes # A private directory, usable only by your_username. Note that your_username requires write access to the directory. [username] comment = Private stuff for your_username path = /mnt/externalhdd/your_username valid users = your_username public = no writable = yes printable = no create mask = 0700 directory mask = 0700 # Custom shares # A share for pictures, accessible only by members of the group \"smbusers\" [pictures] comment = Pictures path = /mnt/externalhdd/pictures public = no browsable = yes writable = yes valid users = @smbusers Test the Samba configuration file.\ntestparm\nThis final part enables the Firewall and allows the Samba ports through it.\nsudo systemctl enable --now firewalld.service\nIn this case, we are using the ‚Äúhome‚Äù firewall zone and the interface ‚Äúeth0‚Äù.\nsudo firewall-cmd --set-default-zone=home\nsudo firewall-cmd --zone=home --change-interface=eth0\nAllow the Samba service through the Firewall.\nsudo firewall-cmd --zone=home --permanent --add-service=samba\nReload the firewall configuration.\nsudo firewall-cmd --reload\nEnable and start the smb and nmb services.\nsudo systemctl enable --now smb.service sudo systemctl enable --now nmb.service\nReboot your Raspberry Pi, and you should have a working Samba server sharing your external HDD.\nsudo systemctl reboot\n","description":"","subtitle":"Sharing files within your LAN","tags":["linux","raspberrypi","opensuse","arm","samba"],"title":"Raspberry Pi4 + openSUSE + Samba","uri":"/en/posts/raspberry_pi4+opensuse+samba/"},{"categories":["tutorials","tips"],"content":"This article is about how to backup dotfiles using Git. I will try to keep it short and straightforward.\nI‚Äôm using Zsh as the shell in the examples, but other shell can be used. The commands below should be executed as a normal user in the /home directory.\nCreate a local Git repository that will be used to track the dotfiles.\ngit init $HOME/.dotfiles\nThe default behaviour of Git commands is to run inside the project folder using information stored at the \u003cproject\u003e/.git directory, and Git assumes that the working tree is located at \u003cproject\u003e. To enable the execution of Git commands specifically for the ‚Äúdotfiles‚Äù repository from anywhere, it is needed to create an alias that indicates the location of the Git directory and the working tree.\nalias dotfiles=‚Äô/usr/bin/git --git-dir=$HOME/.dotfiles/.git --work-tree=$HOME'\nMake this alias permanent.\necho ‚Äúalias dotfiles=‚Äô/usr/bin/git --git-dir=$HOME/.dotfiles/.git --work-tree=$HOME‚Äô‚Äù ¬ª $HOME/.zsh/aliases\nSource the aliases file inside .zshrc file adding the following line.\nsource $HOME/.zsh/aliases\nBy default, Git will consider all the files under the working tree as untracked. To avoid this behaviour, configure Git to show only the files that are explicitly added.\ndotfiles config --local status.showUntrackedFiles no\nAdd the files that you want to track, for example.\ndotfiles add .vimrc .zshrc .gitignore\nLink the local to the remote repository. The remote repository can be a GitHub or any other Git repository.\ndotfiles remote add origin remote-url\nPush the changes to the remote repository. This is effectively the backup of the dotfiles.\ndotfiles push -u origin main\nNow the dotfiles are backed up to the remote repository.\n","description":"","subtitle":"Or any other version control system","tags":["linux","git"],"title":"Backup dotfiles to GitHub","uri":"/en/posts/backup-and-restore-dot-files/"},{"categories":["tutorials","tips"],"content":"For a long time, I ran away from Vim because it seemed very tricky and because there is a lot of simpler editors out there to work with. However, as it comes installed in most Linux distributions, I made this cheat sheet to help me understand how things work. I have discovered that is possible to be very productive with Vim üòÉ.\nI‚Äôll try to go straight to the point. This cheat-sheet is not intended to be a complete guide but it helps to get started.\nVim have different operation modes, and I will not cover all of them in this cheat sheet. I‚Äôll stick with the basic functionality needed to open, edit and save a file.\nLet‚Äôs begin! To open a file with Vim just type vim filename.\nESC = enter ‚Äúcommand mode‚Äù\nMove the cursor You can use the arrow keys to move the cursor around. There is also special keys to do this:\nh = move one character left j = move one row down k = move one row up l = move one character right Edition Mode The following keys have to be typed in ‚ÄúCommand Mode‚Äù.\ni = insert text in the cursor position I = insert text in the begin of the line o = insert text in the next line O = insert text in the previous line a = insert a character after the current A = insert text at the end of the line r = replace the character at the current cursor position R = enter replace mode to replace characters from the current cursor position u = undo last action CTRL + r = redo Saving \u0026 Exiting The following keys have to be typed in ‚ÄúCommand Mode‚Äù.\n:w = Save :q = Exit :q! = Force exit (exit without saving) :qa = Exit from all opened files :wq = Save and exit :x = Save and exit ZZ = Save and exit ZQ = Force exit (exit without saving) Copy, paste \u0026 cut The following keys have to be typed in ‚ÄúCommand Mode‚Äù.\nyy = copy line p = paste content to the below line P = paste content to the above line yNy = copy N lines cw = cut the word starting from the current cursor position dd = cut or delete a line D = delete the line starting from the current cursor position dG = delete the lines starting from the current cursor position to the end of the file dGG = delete the lines starting from the current cursor position to the begin of the file dw = delete the word starting from the current cursor position dNd = cut or delete N lines x = delete a character at the current cursor position (similar to ‚Äúdelete‚Äù key behaviour) X = delete a character before the current cursor position (similar to ‚Äúbackspace‚Äù key behaviour) yw = copy the word starting from the current cursor position Visual Mode The following keys have to be typed in ‚ÄúCommand Mode‚Äù.\nv = visual mode that allows to select a text fragment V = visual mode that allows to select an entire line CTRL+v = visual block that allows select a block of text Navigation The following keys have to be typed in ‚ÄúCommand Mode‚Äù.\n/pattern = search forward for a patter ?pattern = search backward for a pattern n = pattern forward search N = pattern backward search gg = goes to the first line of the file G = goes to the last line of the file H = goes to the top of the current screen M = goes to the middle of the current screen L = goes to the end of the current screen Commands The following keys have to be typed in ‚ÄúCommand Mode‚Äù.\n:set hlsearch = enable search highlight :set number = show line numbers :set tabstop=N = set the size of TAB to N :set expandtab = convert TAB in spaces :set bg=dark/light = change the color scheme :set ignorecase = makes the search case insensitive :syntax on/off = enable/disable syntax highlighting :LNs/tobereplaced/replacer/g = replaces(s) all(g) tobereplaced with replacer in the line LN :%s/tobereplaced/replacer/g = replaces(s) all(g) tobereplaced with replacer in the entire file :e filename = opens ‚Äúfilename‚Äù :r filename = copy the contents of the ‚Äúfilename‚Äù to the current file :split filename = split screen horizontally to show the current file and ‚Äúfilename‚Äù :vsplit filename = split screen vertically to show the current file and ‚Äúfilename‚Äù :! command = runs ‚Äúcommand‚Äù in shell and show the STDOUT !! command = runs ‚Äúcommand‚Äù in shell and paste the STDOUT in the file ","description":"","subtitle":"Sooner or latter you will need it","tags":["linux","vim","editor"],"title":"Vim Cheat Sheet","uri":"/en/posts/vim-cheat-sheet/"},{"categories":["tutorials","tips"],"content":"Hi and welcome to my blog!\nKWallet is a KDE Plasma tool to store any credentials and secrets safely. It has an interface called KWallet Manager that allows to manage credentials and secrets easily.\nIn this quick tutorial, I‚Äôll show how to configure your KDE to store your GitHub credentials in KWallet. This guide was tested against openSUSE Tumbleweed but should work for most Linux distributions.\nFirst, make sure to have ksshaskpass installed. ksshaskpass is an ssh-add helper that uses kwallet and kpassworddialog to show a window where you should type your credentials.\nNow, create an autostart script file and mark it as executable:\ntouch ~/.config/plasma-workspace/env/askpass.sh\nOpen it for edition.\nnano ~/.config/plasma-workspace/env/askpass.sh\nPut the following content in the file:\n1 2 #!/bin/sh export GIT_ASKPASS='/usr/lib/ssh/ksshaskpass' Save and exit. Now make it executable.\nchmod +x ~/.config/plasma-workspace/env/askpass.sh\nNext time you log in, open Konsole and try to clone some of your private GitHub repositories. If your wallet is already open and you will see the ksshaskpass dialogue asking for your user name and then asking for your password. Ensure to mark ‚ÄúRemember password‚Äù to save your credentials safely in your wallet.\n","description":"","subtitle":"Konsole + GitHub + KWallet","tags":["linux","kde","opensuse"],"title":"Secure GitHub credentials with KWallet","uri":"/en/posts/secure-git-credentials-kwallet/"},{"categories":["tutorials"],"content":"Hi and welcome to my blog! Here goes a quick tip on how to properly sort partitions number in Linux.\nLet‚Äôs think that we had a disk /dev/sda with 4 partitions:\n/dev/sda1 /dev/sda2 /dev/sda3 /dev/sda4 Now, if we have to repartition our disk and delete /dev/sda2 and /dev/sda3 to make /dev/sda1 larger, occasionally you will end up with /dev/sda1 and /dev/sda4 when it should be only /dev/sda1 and /dev/sda2.\nTo fix this mess and sort the partitions correctly we can use fdisk that is present by default in almost every Linux installation. Remember that fdisk and most of the partition/disk tools are very powerful and can be dangerous. Make sure to have a backup of your important files.\nNow, let‚Äôs do the job. Begin typing sudo fdisk /dev/sda.\nThan type ‚Äúm‚Äù to see the help.\nPress ‚Äúp‚Äù to print the partitions list.\nYou‚Äôll see that they are unsorted.\nNow, type ‚Äúx‚Äù to access the advanced options.\nThan type ‚Äúm‚Äù again to see the help.\npress ‚Äúf‚Äù to fix partitions order.\npress ‚Äúp‚Äù again to print the partitions list.\nNow, they should be sorted correctly üòâ.\nPress ‚Äúw‚Äù to write changes to disk and exit.\nIt‚Äôs done.\n","description":"","subtitle":"Fix the partition mess","tags":["linux","partitions"],"title":"Sort Linux partitions correctly","uri":"/en/posts/sort-linux-partitions-correctly/"},{"categories":["tutorials"],"content":"Hello and welcome to my blog.\nWe use Windows in our workstations at my current job (it was not my choice üôä), but there are a lot of tasks that are easier to do in a Linux environment. Some days ago I needed to manipulate a huge CSV and just thought: ‚ÄúThis would be a lot simple with cat, grep, sort, etc.‚Äù.\nSo, I remember that I have read something about running Linux inside Windows using WSL and, well, why not give it a try?\nSetting up the environment Some considerations:\nWSL 2 is only available in Windows 10, Version 2004, Build 19041 or higher. Check your Windows version by selecting the Windows logo key + R, typing winver, and selecting OK. All Windows commands should be typed in a PowerShell session with administrative privileges unless otherwise specified (right-click on the PowerShell icon and choose ‚ÄúRun as administrator‚Äù). Here we go! Since I‚Äôm a command-line lover and do not have a Microsoft account to access Microsoft Store, I‚Äôll do this from there as much as possible. First, let‚Äôs install a decent terminal emulator, Microsoft is doing a good job with Windows Terminal. I have downloaded v1.1.2021.0 and renamed it to WindowsTerminal.msixbundle. This is the latest version at the time of writing. The installation is pretty straightforward, just open a PowerShell instance, navigate to the directory where the executable was downloaded and type:\n.\\WindowsTerminal.msixbundle\nNow, click on Instal and wait a few seconds for the windows of Windows Terminal to show up. Close this window, for now, we need to open it as Administrator soon.\nThe next step is to enable WSL. Use the same method stated at the top of the article to launch an instance of Windows Terminal with administrative privileges (damn, I wish that there was a ‚Äúsudo‚Äù for this. Maybe Microsoft can launch an ‚Äúaddo‚Äù üôÉ). Observe that should have a ‚ÄúPS‚Äù before your prompt, this indicates that you are in a PowerShell session. Now type:\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\nThe ‚ÄòVirtual Machine Platform‚Äô is needed to run WSL 2. To enable it, just type:\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\nYou should see ‚ÄúThe operation completed successfully.‚Äù for both commands. Now reboot your computer.\nOnce rebooted, open Windows Terminal again and set WSL2 as default:\nwsl --set-default-version\nIf you already have a distribution installed and like to convert it to use WSL2, this is possible. First, check the current status.\nwsl --list --verbose\nThe above command will show a list of installed distributions separated by NAME, STATE, and VERSION. For instance, if you have an Ubuntu installation that is running at version 1 you can type:\nwsl --set-version Ubuntu 2\nYou also can revert it to WSL 1 if you are not satisfied with the result, just change the version number.\nDownload and installation Now it is time to download the distribution that you wish to install. I chose Debian because it is very light and stable. Since Windows 10 Spring 2018 Update, curl.exe is present, so let‚Äôs use it.\ncurl.exe -L -o debian.appx https://aka.ms/wsl-debian-gnulinux\nThe installation step is also quite simple.\nAdd-AppxPackage .\\debian.appx\nA strange progress bar will be displayed. Once it disappears, it is done. Now Debian should be available in your applications menu, but don‚Äôt click there, use the Windows Terminal to open a Debian session. On the right side of the tab, there is an arrow that hides all the possible sessions. Clicking on Debian will lead you to the user configuration screen. Choose your username and password and you are done.\nConfiguration Now, I recommend that you update the installation:\nsudo apt update \u0026\u0026 sudo apt upgrade\nVerify the version of Debian that was installed.\ncat /etc/os-release\nFor reasons unknown to me, the downloaded image was still the Stretch version of Debian. No problem, let‚Äôs update it to Debian Buster. First, make a backup of your sources.list file.\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\nNow, replace every ‚Äústretch‚Äù entry with ‚Äúbuster‚Äù. You can do this with nano or vi or directly with sed.\nsudo sed -i ‚Äôs/stretch/buster/g‚Äô /etc/apt/sources.list\nThen update the system again.\nsudo apt update \u0026\u0026 sudo apt upgrade \u0026\u0026 sudo apt full-upgrade\nNow get rid of obsolete packages in your system.\nsudo apt autoremove\nClose the Debian tab and open another one to check if you have installed Debian Buster with success.\ncat /etc/os-release\nYou should see something like the below:\n1 2 3 4 5 6 7 8 9 PRETTY_NAME=\"Debian GNU/Linux 10 (buster)\" NAME=\"Debian GNU/Linux\" VERSION_ID=\"10\" VERSION=\"10 (buster)\" VERSION_CODENAME=buster ID=debian HOME_URL=\"https://www.debian.org/\" SUPPORT_URL=\"https://www.debian.org/support\" BUG_REPORT_URL=\"https://bugs.debian.org/\" Final considerations For better file system performance, make sure to store your Linux project files in the Linux file system (not the Windows file system). It is probable that when you open a Debian session your prompt show something like username@hostname:/mnt/c/Users/username$ This is because WSL exposes the Windows file system through mount points placed in /mnt like /mnt/c and /mnt/d just type cd ~ to go to your real home.\nNot only the file system of Windows is exposed by WSL, but you can use Windows applications too, try to type explorer.exe. As you can see, Windows Explorer will open with the files of your current directory loaded.\nThat is it, everything is set up and ready to use.\n","description":"","subtitle":"Useful and cool","tags":["linux","wsl","wsl2","windows"],"title":"Run Debian in Windows 10 with WSL 2","uri":"/en/posts/debian-windows10-wsl2/"},{"categories":["tutorials"],"content":"Hello! In this quick tutorial, I will show you how to convert OVA file to a QCOW2.\nA few days ago I have to install Windows in a virtual environment to test some stuff. Then, I found that Microsoft provides some test images officially at https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/ but there are no images to use with KVM. So, what if it would be possible to convert some of the provided formats to a KVM compatible format?\nWell, this is possible and much easier than I thought it was. Follow me!\nFirst, we have to extract the files from the OVA file.\ntar -xvf MSEdge-Win10.ova\nAn OVA file is an Open Virtualization Appliance that contains a compressed version of a virtual machine. Now we have two files: the MSEdge - Win10-disk001.vmdk and the MSEdge - Win10.ovf. To convert the .vmdk file to a .qcow2 file to import into KVM we just have to use the qemu-img command as follows.\nqemu-img convert MSEdge-Win10-disk001.vmdk the_name_you_want.qcow2 -O qcow2\nObserve that I‚Äôve renamed the file MSEdge - Win10-disk001.vmdk to remove the blank spaces. I always try to do this before work with files in the command line.\nThat‚Äôs it! Now we can just move our converted the_name_you_want.qcow2 to the images directory that is usually /var/lib/libvirt/images, but you can place it wherever you wish and import it.\n","description":"","subtitle":"Easy way to use in KVM","tags":["linux","virtualization"],"title":"Convert OVA to QCOW2","uri":"/en/posts/convert-ova-to-qcow2/"},{"categories":["tutorials"],"content":"Hello, welcome to my blog!\nIn this article, I will show you how to run Arch Linux ARM on the Raspberry Pi 4.\nI think everyone already knows the Raspberry Pi, but if you haven‚Äôt heard about it, click here.\nNow that you know what it is about, let‚Äôs get down to business. It is worth mentioning that a good part of this guide is found in the instructions on the project‚Äôs own page, available here.\nThe first thing to do is to format your MicroSD card. I recommend a good Class 10 card or better.\nThe choice of the partitioning tool is up to you. I will use fdisk which is available by default on most Linux distributions.\nFirst, we start microSD with fdisk. You need to use sudo or perform the process as root. fdisk / dev / sdX\nReplace ‚ÄúX‚Äù with your MicroSD identifier.\nAt the first prompt, delete (!!!) the partitions and create a new one: Press o and ENTER. This will clear the current partitions.\nPress p to list the partitions. There should be none listed.\nPress n and ENTER for a new partition and p to choose the ‚ÄúPrimary‚Äù type. Now 1 for the first partition and ENTER to accept the default value for the first sector. Now type + 100M for the last sector.\nPress t and then c to configure the first partition with type W95 FAT32 (LBA)\nNow press n for a new partition and p again for ‚ÄúPrimary‚Äù. Then 2 for the second partition on the card and press ENTER twice to accept the default values ‚Äã‚Äãfor the first and last sectors of the second partition.\nPress w to write the partition table and exit.\nThis way you guarantee the rest of the card to the system. We will talk about this later.\nCreate and mount the FAT file system that will be filled by the boot files:\nmkfs.vfat / dev / sdX1 mkdir boot mount / dev / sdX1 boot\nCreate and mount the EXT4 file system that will be filled by the system files:\nmkfs.ext4 / dev / sdX2 mkdir root mount / dev / sdX2 root\nDownload and extract the root filesystem. The parameters of the bsdtar command are: x to extract, p to restore permissions, and f indicates the input file. The C after the input file indicates the directory to which we must change before extracting the files, in this case, the root directory we have created. This part MUST be done as the root user:\nwget http://os.archlinuxarm.org/os/ArchLinuxARM-rpi-4-latest.tar.gz bsdtar -xpf ArchLinuxARM-rpi-4-latest.tar.gz -C root sync\nHere‚Äôs a tip: the URL reported in the documentation had an error the day I tried to download it. I went straight to the mirror in Brazil and found it was out of date, took advantage, and reported on IRC # archlinux-arm. I managed to download the latest version using the Danish mirror directly. A list of mirrors is available at https://archlinuxarm.org/about/mirrors\nMove the boot files to the first partition:\nmv root/boot/* boot\nUnmount the two partitions:\numount boot root\nInsert the card into the Raspberry Pi, connect the ethernet cable and the power supply.\nIf you do not use the Raspberry Pi connected directly to a video, keyboard, and mouse, you can connect via SSH. Check the IP assigned by your router‚Äôs DHCP, for example. * Log in with the standard user alarm and password alarm. * The default root password is root.\nLast, but not least: Start the Pacman keychain and populate it with the Arch Linux ARM keys.\npacman-key -- init pacman-key -- populate archlinuxarm\nReady, Arch Linux ARM is ready to be used for the project you want. I recommend updating the system and restarting to start the game.\npacman -Syu systemctl reboot\nIn the next posts, we will talk more about configurations and the use of the system. See you.\n","description":"","subtitle":"Keeping the things simple!","tags":["linux","raspberrypi","arm","archlinux"],"title":"Arch linux ARM on Raspberry Pi 4","uri":"/en/posts/arch_linux_arm-raspberry_pi_4/"},{"categories":["tutorials","productivity"],"content":"Update: Starship configurarion changed in the newer versions. This article was updated and covers the version 1.3.0.\nHi, welcome to my blog!\nThe objective of this article is to share my shell setup with you. I think that my job and day to day tasks became easier and more productive than using the ‚Äúnormal‚Äù bash. I hope that it helps you.\nYou will need the following tools:\nZsh - The Z shell.\nOh-My-Zsh - A framework for managing your Zsh configuration.\nStarship - A fast and customizable prompt for any shell!\nI assume that you already have git installed and have a little knowledge of using it to clone repositories.\nInstalling Zsh First, you need to install Zsh. You can use your distribution package manager to install it easily.\nFor openSUSE:\nsudo zypper install zsh\nFor Ubuntu:\nsudo apt install zsh\nFor Fedora:\nsudo dnf install zsh\nAfter this you should set Zsh as your default shell:\nchsh -s $(which zsh)\nNow reboot your machine.\nInstalling Oh-My-Zsh After rebooting, open your terminal and you should now be prompted by a Zsh configuration wizard. At this time you can just type q and ENTER because you will install and configure Oh-My-Zsh and it will install a .zshrc template for us:\ncurl or wget should be installed. git should be installed. sh -c ‚Äú$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)‚Äù\nIf Oh-My-Zsh was successfully installed, you should see that your prompt changes to a green one. The template configuration file is ~/.zshrc and it gives you tons of possibilities to configure your shell behavior, like prompt themes and plugins.\nLoading some plugins There is a lot of configurations that can be made in Zsh + Oh-My-Zsh, here I‚Äôll just talk about a list of cool plugins that I use, but you can dive deeper to discover more possibilities. Plugins should be placed in plugins=(...) session of the configuration file. I use the following:\nplugin name brief description colored-man-pages adds colors to man pages command-not-found uses the command-not-found package for Zsh to provide suggested packages docker adds auto-completion for docker git provides many aliases and a few useful functions npm provides completion as well as adding many useful aliases pep8 adds completion for pep8 pip adds completion for pip pyenv loads pyenv and pyenv-virtualenv python adds several aliases for useful python commands sudo prefix your current or previous commands with sudo by pressing esc twice systemd provides many useful aliases for systemd ubuntu This plugin adds completions and aliases for Ubuntu zsh_reload type src to reload Zsh session zsh-autosuggestions suggests commands as you type based on history and completions zsh-syntax-highlighting package provides syntax highlighting You can always go to https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins to see a complete list of plugins and their respective documentation.\nThe last two plugins of my list aren‚Äôt part of the default Oh-My-Zsh installation and should be installed separately. Maybe you can install it with your distribution package manager, but I do prefer to install via Github to take advantage of possible new features.\nAs you are using Oh-My-Zsh as a plugin manager, and the plugins are already enabled in our .zshrc file, all you have to do is clone the project repository to our $ZSH_CUSTOM directory. Just type the following commands. For zsh-autosuggestions:\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\nAnd for zsh-syntax-highlighting:\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\nInstalling a better font For better support icons and symbols, you have to install a modern font like Nerd Fonts. I use the Meslo, but you can choose your own and test it.\nMeslo Nerd Fonts Now you have to configure your terminal emulator to use Meslo Nerd Fonts.\nTheming the prompt with Starship To finish the task, the last step is to install Starship that will bring a lot of goodies to our Zsh shell. The installation is very simple, just type:\ncurl should be installed. curl -fsSL https://starship.rs/install.sh | zsh\nOnce installed, you have to enable it. Just place the following line at the end ~/.zshrc\neval ‚Äú$(starship init zsh)‚Äù\nIt is a good idea to comment out the ZSH_THEME entry in ~/.zshrc\nConfiguring Starship The configuration of Starship is easy to understand. First, you need to create de starship.toml file. It should be placed inside ~/.config:\nmkdir -p ~/.config \u0026\u0026 touch ~/.config/starship.toml\nAfter this, you have to fill the file with the options that you wish to change the default setup. By the way, the default setup is quite cool! As the configuration is a .toml file, all the options are of the type key : value, pretty intuitive.\nThe detailed information about every option is well described at the official documentation. However, I paste the one that I‚Äôm using to serve as a reference for you.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 # Inserts a blank line between shell prompts add_newline = true # Customizing the prompt format = \"\"\" $username\\ $hostname\\ $shlvl\\ $singularity\\ $kubernetes\\ $directory\\ $vcsh\\ $git_branch\\ $git_commit\\ $git_state\\ $git_metrics\\ $git_status\\ $hg_branch\\ $docker_context\\ $package\\ $cmake\\ $cobol\\ $dart\\ $deno\\ $dotnet\\ $elixir\\ $elm\\ $erlang\\ $golang\\ $helm\\ $java\\ $julia\\ $kotlin\\ $lua\\ $nim\\ $nodejs\\ $ocaml\\ $perl\\ $php\\ $pulumi\\ $purescript\\ $python\\ $rlang\\ $red\\ $ruby\\ $rust\\ $scala\\ $swift\\ $terraform\\ $vlang\\ $vagrant\\ $zig\\ $nix_shell\\ $conda\\ $memory_usage\\ $aws\\ $gcloud\\ $openstack\\ $azure\\ $env_var\\ $crystal\\ $custom\\ $sudo\\ $cmd_duration\\ $line_break\\ $jobs\\ $battery\\ $time\\ $status\\ $shell\\ [$character](bold green)\"\"\" # Configure if and how the time is shown [time] disabled = false time_format = \"%T\" format = \"üïô[$time ](bold blue)\" [sudo] disabled = false style = \"bold green\" symbol = \"üí™\" format = \"[\u003cSUDO\u003e$symbol]($style)\" [status] disabled = false style = \"bg:blue\" symbol = \"üî¥\" map_symbol = true format = '[\\[$symbol $common_meaning$signal_name$maybe_int\\]]($style) ' Close and reopen your terminal to see the results. Cool! Isn‚Äôt it?!\nThat‚Äôs it! I hope this article can be useful. Thanks for reading!\n","description":"","subtitle":"Increasing productivity","tags":["linux","shell","bash","zsh"],"title":"Installing Zsh + Oh-My-Zsh + Starship","uri":"/en/posts/zsh+oh-my-zsh+starship/"}]
