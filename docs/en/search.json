[{"categories":["tutorials","tips"],"content":"Hi and welcome to my blog!\nKWallet is a KDE Plasma tool to safely store any kind of credentials and secrets. It has an interface called KWallet Manager that allows to easily manage this credentials and secrets.\nIn this quick tutorial, I‚Äôll show how to configure your KDE to store your GitHub credentials in KWallet. This guide was tested against openSUSE Tumbleweed but should work for the most of Linux distributions.\nFirst, make sure to have ksshaskpass installed. ksshaskpass is an ssh-add helper that uses kwallet and kpassworddialog to show a window where you should type your credentials.\nNow, create an autostart script file and mark it as executable:\n touch ~/.config/plasma-workspace/env/askpass.sh\n Open it for edition.\n nano ~/.config/plasma-workspace/env/askpass.sh\n Put the following content in the file:\n1 2 3  #!/bin/sh export GIT_ASKPASS='/usr/lib/ssh/ksshaskpass'   Save and exit. Now make it executable.\n chmod +x ~/.config/plasma-workspace/env/askpass.sh\n Next time you log in, open Konsole and try to clone some of your private GitHub repositories. If your wallet is already open and you will see the ksshaskpass dialogue asking for your user name and then asking for your password. Just make sure to mark ‚ÄúRemember password‚Äù in both dialogues to save your credentials safely in your wallet.\n","description":"","subtitle":"Konsole + GitHub + KWallet","tags":["linux","kde","opensuse"],"title":"Secure GitHub credentials with KWallet","uri":"/en/posts/secure-git-credentials-kwallet/"},{"categories":["tutorials"],"content":"Hi and welcome to my blog! Here goes a quick tip on how to properly sort partitions number in Linux.\nLet‚Äôs think that we had a disk /dev/sda with 4 partitions:\n/dev/sda1 /dev/sda2 /dev/sda3 /dev/sda4  Now, if we have to repartition our disk and delete /dev/sda2 and /dev/sda3 to make /dev/sda1 larger, occasionally you will end up with /dev/sda1 and /dev/sda4 when it should be only /dev/sda1 and /dev/sda2.\nTo fix this mess and sort the partitions correctly we can use fdisk that is present by default in almost every Linux installation. Remember that fdisk and most of the partition/disk tools are very powerful and can be dangerous. Make sure to have a backup of your important files.\nNow, let‚Äôs do the job. Begin typing sudo fdisk /dev/sda.\nThan type ‚Äúm‚Äù to see the help.\nPress ‚Äúp‚Äù to print the partitions list.\nYou‚Äôll see that they are unsorted.\nNow, type ‚Äúx‚Äù to access the advanced options.\nThan type ‚Äúm‚Äù again to see the help.\npress ‚Äúf‚Äù to fix partitions order.\npress ‚Äúp‚Äù again to print the partitions list.\nNow, they should be sorted correctly üòâ.\nPress ‚Äúw‚Äù to write changes to disk and exit.\nIt‚Äôs done.\n","description":"","subtitle":"Fix the partition mess","tags":["linux","partitions"],"title":"Sort Linux partitions correctly","uri":"/en/posts/sort-linux-partitions-correctly/"},{"categories":["tutorials"],"content":"Hello and welcome to my blog.\nWe use Windows in our workstations at my current job (it was not my choice üôä), but there is a lot of tasks that are easier to do in a Linux environment. Some days ago I needed to manipulate a huge CSV and just thought: ‚ÄúThis would be a lot simple with cat, grep, sort, etc.‚Äù.\nSo, I remember that I have read something about running Linux inside Windows using WSL and, well, why not give a try?\nSetting up the environment Some considerations:\n WSL 2 is only available in Windows 10, Version 2004, Build 19041 or higher. Check your Windows version by selecting the Windows logo key + R, type winver, select OK. All Windows commands should be typed in a PowerShell session with administrative privileges unless otherwise specified (right-click in the PowerShell icon and choose ‚ÄúRun as administrator‚Äù).  Here we go! Since I‚Äôm a command-line lover and do not have a Microsoft account to access Microsoft Store, I‚Äôll do this from there as much as possible. First, let‚Äôs install a decent terminal emulator and Microsoft is doing a good job with Windows Terminal. I have downloaded v1.1.2021.0 and renamed it to WindowsTerminal.msixbundle. This is the latest version at the time of writing. The installation is pretty straight forward, just open a PowerShell instance, navigate to the directory where the executable was downloaded and type:\n .\\WindowsTerminal.msixbundle\n Now, click in Instal and wait a few seconds to the windows of Windows Terminal show up. Close this window for now, we need to open it as Administrator soon.\nThe next step is to enable WSL. Use the same method stated at the top of the article to launch an instance of Windows Terminal with administrative privileges (damn, I wish that there was a ‚Äúsudo‚Äù for this. Maybe Microsoft can launch an ‚Äúaddo‚Äù üôÉ). Observe that should have a ‚ÄúPS‚Äù before your prompt, this indicates that you are in a PowerShell session. Now type:\n dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n The ‚ÄòVirtual Machine Platform‚Äô is needed to run WSL 2. To enable it, just type:\n dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n You should see ‚ÄúThe operation completed successfully.‚Äù to both commands. Now reboot your computer.\nOnce rebooted, open Windows Terminal again and set WSL2 as default:\n wsl --set-default-version\n If you already have a distribution installed and like to convert it to use WSL2, this is possible. First, check the current status.\n wsl --list --verbose\n The above command will show a list of installed distributions separated by NAME, STATE, and VERSION. For instance, if you have an Ubuntu installation that is running at version 1 you can type:\n wsl --set-version Ubuntu 2\n You also can revert it to WSL 1 if you are not satisfied with the result, just change the version number.\nDownload and installation Now it is time to download the distribution that you wish to install. I chose Debian because it is very light and stable. Since Windows 10 Spring 2018 Update, curl.exe is present, so let‚Äôs use it.\n curl.exe -L -o debian.appx https://aka.ms/wsl-debian-gnulinux\n The installation step is also quite simple.\n Add-AppxPackage .\\debian.appx\n A strange progress bar will be displayed. Once it disappears, it is done. Now Debian should be available in your applications menu, but don‚Äôt click there, use the Windows Terminal do open a Debian session. On the right side of the tab, there is an arrow that hides all the possible sessions. Clicking on Debian will lead you to the user configuration screen. Choose your username and password and you are done.\nConfiguration Now, I recommend that you update installation:\n sudo apt update \u0026\u0026 sudo apt upgrade\n Verify the version of Debian that was installed.\n cat /etc/os-release\n For an unknown reason by me, the downloaded image was still the Stretch version of Debian. No problem, let‚Äôs update it to Debian Buster. First, make a backup of your sources.list file.\n sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\n Now, replace every ‚Äústretch‚Äù entry with ‚Äúbuster‚Äù. You can do this with nano or vi or directly with sed.\n sudo sed -i ‚Äôs/stretch/buster/g‚Äô /etc/apt/sources.list\n Then update the system again.\n sudo apt update \u0026\u0026 sudo apt upgrade \u0026\u0026 sudo apt full-upgrade\n Now get rid of obsolete packages in your system.\n sudo apt autoremove\n Close the Debian tab and open another one to check if you have installed Debian Buster with success.\n cat /etc/os-release\n You should see something like the below:\nPRETTY_NAME=\"Debian GNU/Linux 10 (buster)\" NAME=\"Debian GNU/Linux\" VERSION_ID=\"10\" VERSION=\"10 (buster)\" VERSION_CODENAME=buster ID=debian HOME_URL=\"https://www.debian.org/\" SUPPORT_URL=\"https://www.debian.org/support\" BUG_REPORT_URL=\"https://bugs.debian.org/\" Final considerations For a better file system performance, make sure to store your Linux project files in the Linux file system (not the Windows file system). It is probable that when you open a Debian session your prompt show something like: username@hostname:/mnt/c/Users/username$ This is why WSL exposes the Windows file system through mount points placed in /mnt like /mnt/c and /mnt/d just type cd ~ to go to your real home.\nNot only the file system of Windows is exposed by WSL, but you can use Windows applications too, try to type explorer.exe . As you can see, Windows Explorer will open with the files of your current directory loaded.\nThat is it, everything is set up and ready to use.\n","description":"","subtitle":"Useful and cool","tags":["linux","wsl","wsl2","windows"],"title":"Run Debian in Windows 10 with WSL 2","uri":"/en/posts/debian-windows10-wsl2/"},{"categories":["tutorials"],"content":"Hello! In this quick tutorial, I will show you how to convert OVA file to a QCOW2.\nA few days ago I have to install Windows in a virtual environment to test some stuff. Then, I found that Microsoft provides some test images officially at https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/ but there are no images to use with KVM. So, what if it would be possible to convert some of the provided formats to a KVM compatible format?\nWell, this is possible and much easier than I thought it was. Follow me!\nFirst, we have to extract the files from the OVA file.\n tar -xvf MSEdge-Win10.ova\n An OVA file is an Open Virtualization Appliance that contains a compressed version of a virtual machine. Now we have two files: the MSEdge - Win10-disk001.vmdk and the MSEdge - Win10.ovf. To convert the .vmdk file to a .qcow2 file to import into KVM we just have to use the qemu-img command as follows.\n qemu-img convert MSEdge-Win10-disk001.vmdk the_name_you_want.qcow2 -O qcow2\n Observe that I‚Äôve renamed the file MSEdge - Win10-disk001.vmdk to remove the blank spaces. I always try to do this before work with files in the command line.\nThat‚Äôs it! Now we can just move our converted the_name_you_want.qcow2 to the images directory that is usually /var/lib/libvirt/images, but you can place it wherever you wish and import it.\n","description":"","subtitle":"Easy way to use in KVM","tags":["linux","virtualization"],"title":"Convert OVA to QCOW2","uri":"/en/posts/convert-ova-to-qcow2/"},{"categories":["tutorials"],"content":"Hello, welcome to my blog!\nIn this article, I will show you how to run Arch Linux ARM on the Raspberry Pi 4.\nI think everyone already knows the Raspberry Pi, but if you haven‚Äôt heard about it, click here.\nNow that you know what it is about, let‚Äôs get down to business. It is worth mentioning that a good part of this guide is found in the instructions on the project‚Äôs own page, available here.\nThe first thing to do is to format your MicroSD card. I recommend a good Class 10 card or better.\nThe choice of the partitioning tool is up to you. I will use fdisk which is available by default on most Linux distributions.\n First, we start microSD with fdisk. You need to use sudo or perform the process as root.  fdisk / dev / sdX\n   Replace ‚ÄúX‚Äù with your MicroSD identifier.\nAt the first prompt, delete (!!!) the partitions and create a new one:    Press o and ENTER. This will clear the current partitions.\n  Press p to list the partitions. There should be none listed.\n  Press n and ENTER for a new partition and p to choose the ‚ÄúPrimary‚Äù type. Now 1 for the first partition and ENTER to accept the default value for the first sector. Now type + 100M for the last sector.\n  Press t and then c to configure the first partition with type W95 FAT32 (LBA)\n  Now press n for a new partition and p again for ‚ÄúPrimary‚Äù. Then 2 for the second partition on the card and press ENTER twice to accept the default values ‚Äã‚Äãfor the first and last sectors of the second partition.\n  Press w to write the partition table and exit.\n  This way you guarantee the rest of the card to the system. We will talk about this later.\n Create and mount the FAT file system that will be filled by the boot files:\n mkfs.vfat / dev / sdX1 mkdir boot mount / dev / sdX1 boot\n   Create and mount the EXT4 file system that will be filled by the system files:\n mkfs.ext4 / dev / sdX2 mkdir root mount / dev / sdX2 root\n   Download and extract the root filesystem. The parameters of the bsdtar command are: x to extract, p to restore permissions, and f indicates the input file. The C after the input file indicates the directory to which we must change before extracting the files, in this case, the root directory we have created. This part MUST be done as the root user:\n wget http://os.archlinuxarm.org/os/ArchLinuxARM-rpi-4-latest.tar.gz bsdtar -xpf ArchLinuxARM-rpi-4-latest.tar.gz -C root sync\n   Here‚Äôs a tip: the URL reported in the documentation had an error the day I tried to download it. I went straight to the mirror in Brazil and found it was out of date, took advantage, and reported on IRC # archlinux-arm. I managed to download the latest version using the Danish mirror directly. A list of mirrors is available at https://archlinuxarm.org/about/mirrors\n Move the boot files to the first partition:\n mv root/boot/* boot\n   Unmount the two partitions:\n umount boot root\n   Insert the card into the Raspberry Pi, connect the ethernet cable and the power supply.\n  If you do not use the Raspberry Pi connected directly to a video, keyboard, and mouse, you can connect via SSH. Check the IP assigned by your router‚Äôs DHCP, for example. * Log in with the standard user alarm and password alarm. * The default root password is root.\n  Last, but not least: Start the Pacman keychain and populate it with the Arch Linux ARM keys.\n pacman-key -- init pacman-key -- populate archlinuxarm\n   Ready, Arch Linux ARM is ready to be used for the project you want. I recommend updating the system and restarting to start the game.\n pacman -Syu systemctl reboot\n In the next posts, we will talk more about configurations and the use of the system. See you.\n","description":"","subtitle":"Keeping the things simple!","tags":["linux","raspberrypi","arm","archlinux"],"title":"Arch linux ARM on Raspberry Pi 4","uri":"/en/posts/arch_linux_arm-raspberry_pi_4/"},{"categories":null,"content":"This is the hardest part of publishing a site. üòÑ\nI‚Äôve criated this blog to be used as a documentation for my day to day learning and to retribute just a little that what I‚Äôve learned reading many articles and tutorials over the years.\nRegarding my career, I entered the IT field very late, but I am always studying to expand my field.\nIn 2017, a while after graduating in Computer Science, I was approved for a public job in IT area. I am currently working there.\nThe good thing is that, as the team is very small, we do a little bit of everything. Infrastructure, development, security. I know it‚Äôs not ideal, but doing what, that‚Äôs what we have! üòÖ\nI am currently dedicating myself to learning Python and JavaScript for real. I‚Äôve been reading a lot about Docker too.\nAnyway, I‚Äôm passionate about Linux and Open Source, Heavy Metal and soccer.\n","description":"","tags":null,"title":"About","uri":"/en/about/"},{"categories":["tutorials","productivity"],"content":"Hi, welcome to my blog!\nThe objective of this article is to share my shell setup with you. I think that my job and day to day tasks became easier and more productive than using the ‚Äúnormal‚Äù bash. I hope that it helps you.\nYou will need the following tools:\nZsh - The Z shell.\nOh-My-Zsh - A framework for managing your Zsh configuration.\nStarship - A fast and customizable prompt for any shell!\nI assume that you already have git installed and have a little knowledge of using it to clone repositories.\nInstalling Zsh First, you need to install Zsh. You can use your distribution package manager to install it easily.\nFor openSUSE:\n sudo zypper install zsh\n For Ubuntu:\n sudo apt install zsh\n For Fedora:\n sudo dnf install zsh\n After this you should set Zsh as your default shell:\n chsh -s $(which zsh)\n Now reboot your machine.\nInstalling Oh-My-Zsh After rebooting, open your terminal and you should now be prompted by a Zsh configuration wizard. At this time you can just type q and ENTER because you will install and configure Oh-My-Zsh and it will install a .zshrc template for us:\n curl or wget should be installed. git should be installed.   sh -c ‚Äú$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)‚Äù\n If Oh-My-Zsh was successfully installed, you should see that your prompt changes to a green one. The template configuration file is ~/.zshrc and it gives you tons of possibilities to configure your shell behavior, like prompt themes and plugins.\nLoading some plugins There is a lot of configurations that can be made in Zsh + Oh-My-Zsh, here I‚Äôll just talk about a list of cool plugins that I use, but you can dive deeper to discover more possibilities. Plugins should be placed in plugins=(...) session of the configuration file. I use the following:\n   plugin name brief description     colored-man-pages adds colors to man pages   command-not-found uses the command-not-found package for Zsh to provide suggested packages   docker adds auto-completion for docker   git provides many aliases and a few useful functions   npm provides completion as well as adding many useful aliases   pep8 adds completion for pep8   pip adds completion for pip   pyenv loads pyenv and pyenv-virtualenv   python adds several aliases for useful python commands   sudo prefix your current or previous commands with sudo by pressing esc twice   systemd provides many useful aliases for systemd   ubuntu This plugin adds completions and aliases for Ubuntu   zsh_reload type src to reload Zsh session   zsh-autosuggestions suggests commands as you type based on history and completions   zsh-syntax-highlighting package provides syntax highlighting    You can always go to https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins to see a complete list of plugins and their respective documentation.\nThe last two plugins of my list aren‚Äôt part of the default Oh-My-Zsh installation and should be installed separately. Maybe you can install it with your distribution package manager, but I do prefer to install via Github to take advantage of possible new features.\nAs you are using Oh-My-Zsh as a plugin manager, and the plugins are already enabled in our .zshrc file, all you have to do is clone the project repository to our $ZSH_CUSTOM directory. Just type the following commands. For zsh-autosuggestions:\n git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n And for zsh-syntax-highlighting:\n git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n Installing a better font For better support icons and symbols, you have to install a modern font like Nerd Fonts. I use the Meslo, but you can choose your own and test it.\n Meslo Nerd Fonts  Now you have to configure your terminal emulator to use Meslo Nerd Fonts.\nTheming the prompt with Starship To finish the task, the last step is to install Starship that will bring a lot of goodies to our Zsh shell. The installation is very simple, just type:\n curl should be installed.   curl -fsSL https://starship.rs/install.sh | zsh\n Once installed, you have to enable it. Just place the following line at the end ~/.zshrc\n eval ‚Äú$(starship init zsh)‚Äù\n It is a good idea to comment out the ZSH_THEME entry in ~/.zshrc\nConfiguring Starship The configuration of Starship is easy to understand. First, you need to create de starship.toml file. It should be placed inside ~/.config:\n mkdir -p ~/.config \u0026\u0026 touch ~/.config/starship.toml\n After this, you have to fill the file with the options that you wish to change the default setup. By the way, the default setup is quite cool! As the configuration is a .toml file, all the options are of the type key : value, pretty intuitive.\nThe detailed information about every option is well described at the official documentation. However, I paste the one that I‚Äôm using to serve as a reference for you.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167  add_newline = true prompt_order = [ \"username\", \"memory_usage\", \"hostname\", \"kubernetes\", \"directory\", \"git_branch\", \"git_commit\", \"git_state\", \"git_status\", \"hg_branch\", \"package\", \"dotnet\", \"elixir\", \"elm\", \"golang\", \"haskell\", \"java\", \"nodejs\", \"php\", \"python\", \"ruby\", \"rust\", \"terraform\", \"nix_shell\", \"conda\", \"aws\", \"env_var\", \"crystal\", \"line_break\", \"battery\", \"cmd_duration\", \"jobs\", \"time\", \"character\", ] [battery] full_symbol = \"üîã\" charging_symbol = \"‚ö°Ô∏è\" discharging_symbol = \"üíÄ\" [[battery.display]] threshold = 10 style = \"bold red\" [[battery.display]] threshold = 60 style = \"bold yellow\" [[battery.display]] threshold = 100 style = \"bold green\" [character] # symbol = \"‚ûú\" error_symbol = \"‚úó\" use_symbol_for_status = true [cmd_duration] min_time = 500 prefix = \"tooks \" [directory] truncation_length = 6 truncate_to_repo = true prefix = \"in \" style = \"bold cyan\" disabled = false # [env_var] # variable = \"SHELL\" # default = \"Zsh\" # prefix = \"\u003c\" # suffix = \"\u003e\" [git_branch] # symbol = \"üå± \" truncation_length = 8 truncation_symbol = \"...\" style = \"bold purple\" disabled = false [git_state] cherry_pick = \"CHERRY PICKING\" rebase = \"REBASING\" merge = \"MERGING\" revert = \"REVERTING\" bisect = \"BISECTING\" am = \"AM\" am_or_rebase = \"AM/REBASE\" progress_divider = \" of \" style = \"bold yellow\" disabled = false # [git_status] # conflicted = \"üè≥\" # ahead = \"üèéüí®\" # behind = \"üò∞\" # diverged = \"üòµ\" # untracked = \"ü§∑‚Äç\" # stashed = \"üì¶\" # modified = \"üìù\" # staged.value = \"++\" # staged.style = \"green\" # staged_count.enabled = true # staged_count.style = \"green\" # renamed = \"üëÖ\" # deleted = \"üóë\" # [[git_status.count]] # enabled = true [hostname] ssh_only = false prefix = \"ü§ñ\" # suffix = \"‚ü´\" trim_at = \".\" disabled = false # [jobs] # symbol = \"+ \" # threshold = 1 [line_break] disabled = false # [memory_usage] # disabled = false # show_percentage = true # show_swap = false # threshold = -1 # symbol = \"Ô°ö \" # separator = \"/\" # style = \"bold dimmed white\" [nodejs] symbol = \"‚¨¢ \" style = \"bold green\" disabled = false # [package] # symbol = \"üì¶ \" # style = \"bold red\" # disabled = false [python] symbol = \"üêç \" pyenv_version_name = false pyenv_prefix = \"pyenv\" style = \"bold yellow\" disabled = false # [time] # format = \"üïô%T\" # style_root = \"bold red\" # style_user = \"bold yellow\" # show_always = true # disabled = false [username] style_root = \"bold red\" style_user = \"bold yellow\" show_always = false disabled = false   Close and reopen your terminal to see the results. Cool! Isn‚Äôt it?!\nThat‚Äôs it! I hope this article can be useful. Thanks for reading!\n","description":"","subtitle":"Increasing productivity","tags":["linux","shell","bash","zsh"],"title":"Installing Zsh + Oh-My-Zsh + Starship","uri":"/en/posts/zsh+oh-my-zsh+starship/"}]
